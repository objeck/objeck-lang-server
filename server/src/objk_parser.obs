use Collection.Generic;

bundle LSP {
	#
	# Parser
	#
	class Parser {
		@text : String;
		@tokens : Vector<Token>;
		@token_index : Int;
		@findings : Vector<Finding>;
		@symbol_scope : Stack<Symbol>;

		New(file : String) {
			@text := System.IO.File.FileReader->ReadFile(file);
			@findings := Vector->New()<Finding>;
			@symbols := Vector->New()<Symbol>;
			@symbol_scope := Stack->New()<Symbol>;
		}

#~ ~#
		function : Main(args : String[]) ~ Nil {
			timer := System.Time.Timer->New();
			timer->Start();			
			
			if(args->Size() = 1) {
				parser := Parser->New(args[0]);
				if(parser->Parse()) {
#					symbols := parser->GetSymbolsObj()->ToString();
#					"Foo = {$symbols}"->PrintLine();
				};
			};

			timer->End();
			timer->GetElapsedTime()->PrintLine();
		}
#~ ~#

		method : public : GetSymbolsObj() ~ Data.JSON.JsonElement {
			builder := Data.JSON.JsonBuilder->New();

			builder->PushArray();
			obj := builder->Pop();

			return obj;
		}

		method : public : Parse() ~ Bool {
			@tokens := Scanner->New(@text)->Scan()<Token>;
DumpTokens();

			ParseUses();
			return ParseClass();
		}

		method : ParseUses() ~ Bool {
			if(Match(Token->Type->USE_ID)) {
				while(Match(Token->Type->USE_ID)) {					
					NextToken();

					if(<>Match(Token->Type->IDENT)) {
						return false;
					};
					NextToken();

					if(<>Match(Token->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				};
			};

			return true;
		}

		method : ParseClass() ~ Bool {
			if(<>Match(Token->Type->CLASS_ID)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
			symbol := Symbol->New(GetToken()->GetStringValue(), Symbol->Kind->CLASS);
			symbol->SetStart(GetToken());
			@symbol_scope->Push(symbol);
			NextToken();

			if(<>Match(Token->Type->OCPN)) {
				return false;
			};
			NextToken();

			done := false;
			do {
				if(Match(Token->Type->FUNCTION_ID) | Match(Token->Type->METHOD_ID)) {
					if(<>ParseMethod(Match(Token->Type->FUNCTION_ID))) {
						return false;
					};
				}
				else if(Match(Token->Type->IDENT)) {
					if(<>ParseDeclaration()) {
						return false;
					};

					if(<>Match(Token->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else {
					done := true;
				};
			}
			while(<>done);

			if(<>Match(Token->Type->CCPN)) {
				return false;
			};
			NextToken();

@symbol_scope->Pop()->ToString()->PrintLine();

			return true;
		}

		method : ParseMethod(is_func : Bool) ~ Bool {
			NextToken();

			if(<>Match(Token->Type->COLON)) {
				return false;
			};
			NextToken();

			if(Match(Token->Type->NATIVE_ID)) {
				NextToken();

				if(<>Match(Token->Type->COLON)) {
					return false;
				};
				NextToken();
			};

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
			parent := @symbol_scope->Top();
			child := Symbol->New(GetToken()->GetStringValue(), Symbol->Kind->FUNCTION, parent);
			child->SetStart(GetToken());
			parent->AddChild(child);
			@symbol_scope->Push(child);
			NextToken();

#~
			# create symbol
			symbol : Symbol;
			token := @tokens->Get(@token_index);
			if(is_func) {
				symbol := Symbol->New(Symbol->Kind->FUNCTION, token->GetStringValue());
			}
			else {
				symbol := Symbol->New(Symbol->Kind->METHOD, token->GetStringValue());
			};
			symbol->SetStart(token->GetLine(), token->GetPos());
			NextToken();

			token := @tokens->Get(@token_index);
			symbol->SetEnd(token->GetLine(), token->GetPos());
			@symbols->AddBack(symbol);
~#

			# declarations
			if(<>ParseDeclarationParameters()) {
				return false;
			};

			if(<>Match(Token->Type->TILDE)) {
				return false;
			};
			NextToken();

			if(<>ParseType()) {
				return false;
			};

			if(<>Match(Token->Type->OCPN)) {
				return false;
			};
			NextToken();

			# statements
			if(<>ParseStatements()) {
				return false;
			};

			if(<>Match(Token->Type->CCPN)) {
				return false;
			};
			NextToken();

			@symbol_scope->Pop();

			return true;
		}

		method : ParseDeclaration() ~ Bool {
			if(<>Match(Token->Type->IDENT)) {
				return false;
			};

			parent := @symbol_scope->Top();
			child := Symbol->New(GetToken()->GetStringValue(), Symbol->Kind->VARIABLE, parent);
			child->SetStart(GetToken());
			parent->AddChild(child);
# Dump(2);
			NextToken();

			if(<>Match(Token->Type->COLON)) {
				return false;
			};
			NextToken();

			if(Match(Token->Type->STATIC_ID)) {
				NextToken();

				if(<>Match(Token->Type->COLON)) {
					return false;
				};
				NextToken();
			};
			
			if(<>ParseType()) {
				return false;
			};

			return true;
		}

		method : ParseDeclarationParameters() ~ Bool {
			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			while(<>Match(Token->Type->CPN)) {
				if(<>ParseDeclaration()) {
					return false;
				};

				if(Match(Token->Type->ASSIGN)) {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				};

				if(Match(Token->Type->COMMA)) {
					NextToken();
				};
			};
			NextToken();
			
			return true;
		}

		method : ParseStatements() ~ Bool {
			done := false;

			do {
				if(Match(Token->Type->IDENT) & Match(Token->Type->COLON, 1)) {
					if(<>ParseAssignmentDeclaration()) {
						return false;
					};
				}
				else if(Match(Token->Type->IDENT) | Match(Token->Type->STRING_LIT)) {
					if(<>ParseSimpleStatement()) {
						return false;
					};

				}
				else if(Match(Token->Type->RETURN_ID)) {
					if(<>ParseReturn()) {
						return false;
					};
				}
				else if(Match(Token->Type->EACH_ID)) {
					if(<>ParseEach()) {
						return false;
					};
				}
				else if(Match(Token->Type->FOR_ID)) {
					if(<>ParseFor()) {
						return false;
					};
				}
				else if(Match(Token->Type->IF_ID)) {
					if(<>ParseIfWhile()) {
						return false;
					};

					while(Match(Token->Type->ELSE_ID)) {
						if(Match(Token->Type->IF_ID, 1)) {
							NextToken();
						};

						if(<>ParseBody()) {
							return false;
						};

					};
					
					if(<>Match(Token->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else if(Match(Token->Type->WHILE_ID)) {
					if(<>ParseIfWhile()) {
						return false;
					};

					if(<>Match(Token->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else {
					done := true;
				};
			}
			while(<>done);

			return true;
		}

		method : ParseSimpleStatement() ~ Bool {
			if(Match(Token->Type->IDENT)) {
# Dump(4);				
			};

			NextToken();

			select(GetType()) {
				label Token->Type->ASSIGN
				label Token->Type->ADD_EQL
				label Token->Type->SUB_EQL
				label Token->Type->MUL_EQL
				label Token->Type->DIV_EQL {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				}
				
				label Token->Type->OPN {
					if(<>ParseCallParameters()) {	
						return false;
					};
				}

				label Token->Type->ASSESSOR {
					NextToken();
				}

				other { 
					return false;
				}
			};

			if(Match(Token->Type->SEMI_COLON) | Match(Token->Type->ASSESSOR)) {
				NextToken();
			};

			return true;
		}

		method : ParseAssignmentDeclaration() ~ Bool {
			if(<>ParseDeclaration()) {
				return false;
			};

			if(Match(Token->Type->ASSIGN)) {
				NextToken();

				if(<>ParseExpression()) {
					return false;
				};
			};

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseIfWhile() ~ Bool {
			NextToken();

			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(Token->Type->CPN)) {
				return false;
			};
			
			return ParseBody();
		}

		method : ParseFor() ~ Bool {
			NextToken();

			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			if(Match(Token->Type->IDENT) & Match(Token->Type->COLON, 1)) {
				if(<>ParseAssignmentDeclaration()) {
					return false;
				};
			}
			else if(Match(Token->Type->IDENT)) {
				if(<>ParseSimpleStatement()) {
					return false;
				};
			}
			else {
				return false;
			};

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			if(<>ParseSimpleStatement()) {
				return false;
			};
						
			if(<> ParseBody()) {
				return false;
			};

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}
		
		method : ParseEach() ~ Bool {
			NextToken();

			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
# Dump(3);			
			NextToken();

			if(<>Match(Token->Type->COLON)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
# Dump(3);
			NextToken();

			if(<>Match(Token->Type->CPN)) {
				return false;
			};
			
			if(<>ParseBody()) {
				return false;
			};

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseBody() ~ Bool {
			NextToken();

			# statements
			if(<>Match(Token->Type->OCPN)) {
				return false;
			};
			NextToken();

			if(<>ParseStatements()) {
				return false;
			};

			if(<>Match(Token->Type->CCPN)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseExpression() ~ Bool {
			done := false;

			do {
				if(<>ParseSimpleExpression()) {
					return false;
				};

				select(GetType()) {
					label Token->Type->AND
					label Token->Type->OR
					label Token->Type->EQL
					label Token->Type->NEQL
					label Token->Type->LES
					label Token->Type->GTR
					label Token->Type->LES_EQL
					label Token->Type->GTR_EQL
					label Token->Type->ADD
					label Token->Type->SUB
					label Token->Type->MUL
					label Token->Type->DIV
					label Token->Type->MOD {
						NextToken();
					}

					other {
						done := true;
					}
				};
			}
			while(<>done);

			return true;
		}

		method : ParseSimpleExpression() ~ Bool {
			select(GetType()) {
				label Token->Type->STRING_LIT
				label Token->Type->CHAR_LIT
				label Token->Type->INT_LIT
				label Token->Type->FLOAT_LIT {
					NextToken();

					return true;
				}

				label Token->Type->IDENT {
# Dump(4);
					NextToken();
					
					if(Match(Token->Type->ASSESSOR)) {
						while(Match(Token->Type->ASSESSOR)) {
							NextToken();

							if(Match(Token->Type->IDENT)) {
# Dump(5);
								NextToken();

								if(Match(Token->Type->OPN)) {
									if(<>ParseCallParameters()) {
										return false;
									};
								};
							}
							else if(Match(Token->Type->AS_ID)) {
								NextToken();

								if(<>Match(Token->Type->OPN)) {
									return false;
								};
								NextToken();

								if(<>ParseType()) {
									return false;
								};

								if(<>Match(Token->Type->CPN)) {
									return false;
								};
								NextToken();
							};
						};
					}
					else if(Match(Token->Type->OPN)) {
						if(<>ParseCallParameters()) {
							return false;
						};
					}
					else if(Match(Token->Type->OBR)) {
						NextToken();

						if(<>ParseExpression()) {
							return false;
						};

						if(<>Match(Token->Type->CBR)) {
							return false;
						};
						NextToken();
					};

					return true;
				}

				label Token->Type->NIL_ID {
					NextToken();

					return true;
				}

				label Token->Type->INT_ID
				label Token->Type->FLOAT_ID
				label Token->Type->CHAR_ID
				label Token->Type->BYTE_ID {
					NextToken();

					if(<>Match(Token->Type->ASSESSOR)) {
						return false;
					};
					NextToken();

					if(Match(Token->Type->IDENT)) {
# Dump(6);
						NextToken();

						if(<>ParseCallParameters()) {
							return false;
						};
					};

					return true;
				}

				label Token->Type->OPN {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};

					if(<>Match(Token->Type->CPN)) {
						return false;
					};
					NextToken();

					return true;	
				}
			};

			return false;
		}

		method : ParseCallParameters() ~ Bool {
			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->CPN)) {
				if(<>ParseExpression()) {
					return false;
				};
				if(Match(Token->Type->COMMA)) {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				};
			};

			if(<>Match(Token->Type->CPN)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseReturn() ~ Bool {
			NextToken();

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseType() ~ Bool {
			select(GetType()) {
				label Token->Type->NIL_ID
				label Token->Type->STRING_ID
				label Token->Type->INT_ID
				label Token->Type->FLOAT_ID
				label Token->Type->CHAR_ID
				label Token->Type->BYTE_ID {
					NextToken();
				}

				label Token->Type->IDENT {
					NextToken();
				}

				other {
					return false;
				}
			};

			if(Match(Token->Type->OBR)) {
				NextToken();

				while(Match(Token->Type->COMMA)) {
					NextToken();
				};

				if(<>Match(Token->Type->CBR)) {
					return false;
				};
				NextToken();
			};

			return true;
		}

		method : NextToken() ~ Nil {
			if(@token_index < @tokens->Size()) {
				@token_index += 1;
			};
		}

		method : GetType() ~ Token->Type {
			if(@token_index < @tokens->Size()) {
				return @tokens->Get(@token_index)->GetType();
			};

			return Token->Type->EOS;
		}

		method : GetToken() ~ Token {
			if(@token_index < @tokens->Size()) {
				return @tokens->Get(@token_index);
			};

			return Nil;
		}

		method : Match(type : Token->Type, offset : Int := 0) ~ Bool {
			index := @token_index + offset;
			if(index < @tokens->Size()) {
				return @tokens->Get(index)->GetType() = type;
			};

			return false;
		}

		method : DumpTokens() ~ Nil {
			each(i : @tokens) {
				token := @tokens->Get(i);
				"{$i}: {$token}"->PrintLine();
			};
		}

		method : Dump(id : Int) ~ Nil {
			if(@token_index < @tokens->Size()) {
				token := @tokens->Get(@token_index);
				"--- {$id}: {$token} ---"->PrintLine();
			};
		}
	}

	#
	# Scanner
	#
	class : private : Scanner {
		@tokens : Vector<Token>;
		@buffer : Char[];
		@buffer_index : Int;
		@cur_char : Char;
		@next_char : Char;
		@line_num : Int;
		@line_index : Int;
		@keywords : Hash<String, IntHolder>;

		New(text : String) {
			@buffer := text->ToCharArray();
			@buffer_index := 0;

			@tokens := Vector->New()<Token>;
			@keywords := Hash->New()<String, IntHolder>;
			@keywords->Insert("return", IntHolder->New(Type->RETURN_ID));
			@keywords->Insert("class", IntHolder->New(Type->CLASS_ID));
			@keywords->Insert("use", IntHolder->New(Type->USE_ID));
			@keywords->Insert("enum", IntHolder->New(Type->ENUM_ID));
			@keywords->Insert("bundle", IntHolder->New(Type->BUNDLE_ID));
			@keywords->Insert("consts", IntHolder->New(Type->CONSTS_ID));
			@keywords->Insert("function", IntHolder->New(Type->FUNCTION_ID));
			@keywords->Insert("method", IntHolder->New(Type->METHOD_ID));
			@keywords->Insert("public", IntHolder->New(Type->PUBLIC_ID));
			@keywords->Insert("private", IntHolder->New(Type->PRIVATE_ID));
			@keywords->Insert("native", IntHolder->New(Type->NATIVE_ID));
			@keywords->Insert("static", IntHolder->New(Type->STATIC_ID));
			@keywords->Insert("Nil", IntHolder->New(Type->NIL_ID));
			@keywords->Insert("String", IntHolder->New(Type->STRING_ID));
			@keywords->Insert("Int", IntHolder->New(Type->INT_ID));
			@keywords->Insert("Float", IntHolder->New(Type->FLOAT_ID));
			@keywords->Insert("Char", IntHolder->New(Type->CHAR_ID));
			@keywords->Insert("Byte", IntHolder->New(Type->BYTE_ID));
			@keywords->Insert("each", IntHolder->New(Type->EACH_ID));
			@keywords->Insert("for", IntHolder->New(Type->FOR_ID));
			@keywords->Insert("while", IntHolder->New(Type->WHILE_ID));
			@keywords->Insert("if", IntHolder->New(Type->IF_ID));
			@keywords->Insert("else", IntHolder->New(Type->ELSE_ID));
			@keywords->Insert("As", IntHolder->New(Type->AS_ID));
		}

		method : NextChar() ~ Nil {
			if(@buffer_index + 1 < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;
				@next_char := @buffer[@buffer_index];
			}
			else if(@buffer_index < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;				
				@next_char := '\0';
			}
			else {
				@cur_char := @next_char := '\0';
			};
		}

		method : Whitespace() ~ Nil {
			while(@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n') {
				if(@cur_char = '\n') {
					@line_num += 1;
					@line_index := 0;
				};

				NextChar();
			};
		}

		method : Comment() ~ Nil {
			if(@cur_char = '#') {
				NextChar();

				if(@cur_char = '~') {
					NextChar();
					while(<>(@cur_char = '~' & @next_char = '#') & @cur_char <> '\0') {
						if(@cur_char = '\n') {
							@line_num += 1;
						};
						NextChar();
					};
					NextChar();
					NextChar();
				}
				else {
					while(@cur_char <> '\n' & @cur_char <> '\0') {
						NextChar();
					};
					@line_num += 1;
					NextChar();
				};

				Whitespace();
			};
		}

		method : ParseIdentifier() ~ Nil {
			start := @buffer_index;
			start_index := @line_index - 1;

			while(@cur_char->IsChar() | @cur_char->IsDigit() | @cur_char = '.' | @cur_char = '_' | @cur_char = '@') {
				NextChar();
			};
			ident := String->New(@buffer, start - 1, @buffer_index - start);

			found := @keywords->Find(ident);
			if(found <> Nil) {
				type := found->Get()->As(Token->Type);
				@tokens->AddBack(Token->New(type, ident, @line_num, start_index));
			}
			else {
				@tokens->AddBack(Token->New(Token->Type->IDENT, ident, @line_num, start_index));
			};
		}

		method : ParseNumber() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			is_float := false;
			while(@cur_char->IsDigit() | @cur_char = '.' | @cur_char = 'u' | @cur_char = 'x') {
				if(@cur_char = '.') {
					is_float := true;
				};

				NextChar();
			};

			ident := String->New(@buffer, start - 1, @buffer_index - start);
			if(is_float) {
				@tokens->AddBack(Token->New(ident->ToFloat(), @line_num, start_index));
			}
			else {
				@tokens->AddBack(Token->New(ident->ToInt(), @line_num, start_index));
			};
		}

		method : ParseString() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;
			
			prev_char := '\0';
			do {
				prev_char := @cur_char;
				NextChar();
			}
			while(<>(@cur_char = '"' & prev_char <> '\\') & @cur_char <> '\0');
			
			ident := String->New(@buffer, start, @buffer_index - start - 1);
			NextChar();

			@tokens->AddBack(Token->New(Token->Type->STRING_LIT, ident, @line_num, start_index));
		}

		method : ParseChar() ~ Nil {
			NextChar();

			if(@cur_char = '\\') {
				select(@next_char) {
					label 'r' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(Token->New('\r', @line_num, start_index));
					}

					label 'n' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(Token->New('\n', @line_num, start_index));
					}

					label 't' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(Token->New('\t', @line_num, start_index));
					}
				};
			}
			else {
				start_index := @line_index - 1;
				@tokens->AddBack(Token->New(@cur_char, @line_num, start_index));
			};

			NextChar();
			if(@cur_char = '\'') {
				NextChar();
				
			}
			else {
				start_index := @line_index - 1;
				@tokens->AddBack(Token->New(Token->Type->OTHER, @cur_char, @line_num, start_index));
				NextChar();
			};
		}

		method : public : Scan() ~ Vector<Token> {
			NextChar();

			while(@cur_char <> '\0') {
				Whitespace();
				Comment();

				if(@cur_char->IsChar() | @cur_char = '@' | @cur_char = '_') {
					ParseIdentifier();
				}
				else if(@cur_char->IsDigit()) {
					ParseNumber();
				}
				else if(@cur_char = '"') {
					ParseString();
				}
				else if(@cur_char = '\'') {
					ParseChar();
				}
				else {
					select(@cur_char) {
						label '<' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->LES_EQL, @line_num, start_index));
								NextChar();
							}
							else if(@next_char = '>') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->NEQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->LES, @line_num, start_index));
								NextChar();
							};
						}

						label '>' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->GTR_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->GTR, @line_num, start_index));
								NextChar();
							};
						}

						label ';' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->SEMI_COLON, @line_num, start_index));
							NextChar();
						}

						label ',' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->COMMA, @line_num, start_index));
							NextChar();
						}

						label '{' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OCPN, @line_num, start_index));
							NextChar();
						}

						label '}' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CCPN, @line_num, start_index));
							NextChar();
						}

						label '(' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OPN, @line_num, start_index));
							NextChar();
						}

						label ')' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CPN, @line_num, start_index));
							NextChar();
						}

						label '=' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->EQL, @line_num, start_index));
							NextChar();
						}

						label ':' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ASSIGN, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->COLON, @line_num, start_index));
								NextChar();
							};
						}

						label '~' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->TILDE, @line_num, start_index));
							NextChar();
						}

						label '&' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->AND, @line_num, start_index));
							NextChar();
						}

						label '|' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OR, @line_num, start_index));
							NextChar();
						}

						label '[' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OBR, @line_num, start_index));
							NextChar();
						}

						label ']' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CBR, @line_num, start_index));
							NextChar();
						}

						label '+' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ADD_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ADD, @line_num, start_index));
								NextChar();
							};
						}
						
						label '*' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->MUL_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->MUL, @line_num, start_index));
								NextChar();
							};
						}

						label '/' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->DIV_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->DIV, @line_num, start_index));
								NextChar();
							};
						}

						label '%' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->MOD, @line_num, start_index));
							NextChar();
						}

						label '-' {
							if(@next_char = '>') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ASSESSOR, @line_num, start_index));
								NextChar();
							}
							else if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->SUB_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->SUB, @line_num, start_index));
								NextChar();
							};
						}
						
						label'←' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->ASSIGN, @line_num, start_index));
							NextChar();
						}

						label '→' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->ASSESSOR, @line_num, start_index));
							NextChar();
						}

						label '\0' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->EOS, @line_num, start_index));
							NextChar();
						}

						other {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OTHER, @cur_char, @line_num, start_index));
							NextChar();
						}
					};
				};
			};

			@tokens->AddBack(Token->New(Token->Type->EOS, @line_num, 0));
			return @tokens;
		}
	}

	#
	# Token
	#
	class : private : Token {
		@type : Token->Type;
		@line_num : Int;
		@line_index : Int;
		@str_value : String;
		@int_value : Int;
		@float_value : Float;
		@char_value : Char;

		enum Type {
			OTHER,
			EOS,
			IDENT,
			STRING_LIT,
			INT_LIT,
			FLOAT_LIT,
			CHAR_LIT,
			EQL,
			NEQL,
			LES,
			GTR,
			LES_EQL,
			GTR_EQL,
			SEMI_COLON,
			ADD,
			SUB,
			MUL,
			DIV,
			MOD,
			ADD_EQL,
			SUB_EQL,
			MUL_EQL,
			DIV_EQL,
			COLON,
			COMMA,
			TILDE,
			AND,
			OR,
			OPN,
			CPN,
			OCPN,
			CCPN,
			OBR,
			CBR,
			ASSESSOR,
			ASSIGN,
			RETURN_ID,
			CLASS_ID,
			USE_ID,
			ENUM_ID,
			CONSTS_ID,
			FUNCTION_ID,
			METHOD_ID,
			PUBLIC_ID,
			PRIVATE_ID,
			BUNDLE_ID,
			NATIVE_ID,
			STATIC_ID,
			NIL_ID,
			STRING_ID,
			INT_ID,
			FLOAT_ID,
			CHAR_ID,
			BYTE_ID,
			EACH_ID,
			FOR_ID,
			WHILE_ID,
			IF_ID,
			ELSE_ID,
			AS_ID
		}

		New(type : Token->Type, line_num : Int, line_index : Int) {
			@type := type;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, str_value : String, line_num : Int, line_index : Int) {
			@type := type;
			@str_value := str_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(int_value : Int, line_num : Int, line_index : Int) {
			@type := Token->Type->INT_LIT;
			@int_value := int_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(float_value : Float, line_num : Int, line_index : Int) {
			@type := Token->Type->FLOAT_LIT;
			@float_value := float_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(char_value : Char, line_num : Int, line_index : Int) {
			@type := Token->Type->CHAR_LIT;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, char_value : Char, line_num : Int, line_index : Int) {
			@type := type;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		method : public : GetType() ~ Token->Type {
			return @type;
		}

		method : public : GetLine() ~ Int {
			return @line_num;
		}

		method : public : GetPos() ~ Int {
			return @line_index;
		}

		method : public : GetStringValue() ~ String {
			return @str_value;
		}

		method : public : GetIntValue() ~ Int {
			return @int_value;
		}

		method : public : GetFloatValue() ~ Float {
			return @float_value;
		}

		method : public : GetCharValue() ~ Char {
			return @char_value;
		}

		method : public : ToString() ~ String {
			buffer := "type=";

			select(@type) {
				label Token->Type->IDENT {
					buffer += "IDENT, value='{$@str_value}'";
				}

				label Token->Type->STRING_LIT {
					buffer += "STRING_LIT, value='{$@str_value}'";
				}

				label Token->Type->INT_LIT {
					buffer += "INT_LIT, value={$@int_value}";
				}
				
				label Token->Type->FLOAT_LIT {
					buffer += "FLOAT_LIT, value={$@float_value}";
				}
				
				label Token->Type->CHAR_LIT {
					buffer += "CHAR_LIT, value='{$@char_value}'";
				}

				label Token->Type->ASSESSOR {
					buffer += "ASSESSOR";
				}

				label Token->Type->SEMI_COLON {
					buffer += "SEMI_COLON";
				}

				label Token->Type->LES {
					buffer += "LES";
				}

				label Token->Type->LES_EQL {
					buffer += "LES_EQL";
				}

				label Token->Type->GTR_EQL {
					buffer += "GTR_EQL";
				}

				label Token->Type->GTR {
					buffer += "GTR";
				}

				label Token->Type->ENUM_ID {
					buffer += "ENUM_ID";
				}

				label Token->Type->CONSTS_ID {
					buffer += "CONSTS_ID";
				}

				label Token->Type->ADD_EQL {
					buffer += "ADD_EQL";
				}

				label Token->Type->SUB_EQL {
					buffer += "SUB_EQL";
				}

				label Token->Type->MUL_EQL {
					buffer += "MUL_EQL";
				}

				label Token->Type->DIV_EQL {
					buffer += "DIV_EQL";
				}

				label Token->Type->EQL {
					buffer += "EQL";
				}

				label Token->Type->NEQL {
					buffer += "NEQL";
				}

				label Token->Type->ADD {
					buffer += "ADD";
				}

				label Token->Type->SUB {
					buffer += "SUB";
				}

				label Token->Type->MUL {
					buffer += "MUL";
				}

				label Token->Type->DIV {
					buffer += "DIV";
				}

				label Token->Type->MOD {
					buffer += "MOD";
				}

				label Token->Type->ASSIGN {
					buffer += "ASSIGN";
				}

				label Token->Type->FUNCTION_ID {
					buffer += "FUNCTION_ID";
				}

				label Token->Type->METHOD_ID {
					buffer += "METHOD_ID";
				}

				label Token->Type->CLASS_ID {
					buffer += "CLASS_ID";
				}

				label Token->Type->RETURN_ID {
					buffer += "RETURN_ID";
				}

				label Token->Type->USE_ID {
					buffer += "USE_ID";
				}

				label Token->Type->PUBLIC_ID {
					buffer += "PUBLIC_ID";
				}

				label Token->Type->PRIVATE_ID {
					buffer += "PRIVATE_ID";
				}

				label Token->Type->BUNDLE_ID {
					buffer += "BUNDLE_ID";
				}

				label Token->Type->NATIVE_ID {
					buffer += "NATIVE_ID";
				}

				label Token->Type->STATIC_ID {
					buffer += "STATIC_ID";
				}

				label Token->Type->NIL_ID {
					buffer += "NIL_ID";
				}

				label Token->Type->STRING_ID {
					buffer += "STRING_ID";
				}

				label Token->Type->INT_ID {
					buffer += "INT_ID";
				}

				label Token->Type->FLOAT_ID {
					buffer += "FLOAT_ID";
				}

				label Token->Type->CHAR_ID {
					buffer += "CHAR_ID";
				}

				label Token->Type->BYTE_ID {
					buffer += "BYTE_ID";
				}

				label Token->Type->EACH_ID {
					buffer += "EACH_ID";
				}

				label Token->Type->FOR_ID {
					buffer += "FOR_ID";
				}

				label Token->Type->AS_ID {
					buffer += "AS_ID";
				}

				label Token->Type->WHILE_ID {
					buffer += "WHILE_ID";
				}

				label Token->Type->IF_ID {
					buffer += "IF_ID";
				}

				label Token->Type->ELSE_ID {
					buffer += "ELSE_ID";
				}

				label Token->Type->COLON {
					buffer += "COLON";
				}
				
				label Token->Type->COMMA {
					buffer += "COMMA";
				}
				
				label Token->Type->TILDE {
					buffer += "TILDE";
				}

				label Token->Type->AND {
					buffer += "AND";
				}

				label Token->Type->OR {
					buffer += "OR";
				}
				
				label Token->Type->OCPN {
					buffer += "OCPN";
				}
				
				label Token->Type->CCPN {
					buffer += "CCPN";
				}

				label Token->Type->OPN {
					buffer += "OPN";
				}
				
				label Token->Type->CPN {
					buffer += "CPN";
				}

				label Token->Type->OBR {
					buffer += "OBR";
				}

				label Token->Type->CBR {
					buffer += "CBR";
				}
				
				label Token->Type->OTHER {
					id := @char_value->As(Int);
					buffer += "OTHER: id={$id}, value='{$@char_value}'";
				}
			};
			buffer += ", line={$@line_num}, pos={$@line_index}";

			return buffer;
		}
	}

	#
	# Symbol
	#
	class Symbol {
		@name : String;
		@kind : Symbol->Kind;
		@pos : Token;
		@parent : Symbol;
		@children : Vector<Symbol>;

		consts Kind {
			MODULE := 9,
			CLASS := 7,
			INTERFACE := 8,
			ENUM := 13,
			METHOD := 2,
			FUNCTION := 3,
			CONSTRUCTOR := 4,
			STRUCT := 22,
			VARIABLE := 13
		}

		New(name : String, kind : Symbol->Kind, parent : Symbol := Nil) {
			@name := name;
			@kind := kind;
			@parent := parent;
			@children := Vector->New()<Symbol>;
		}

		method : public : AddChild(child : Symbol) ~ Nil {
			@children->AddBack(child);
		}

		method : public : SetStart(start : Token) ~ Nil {
			@pos := start;
		}

		method : public : ToString() ~ String {
			return ToString(0);
		}

		method : ToString(depth : Int) ~ String {
			kind := @kind->As(Int);
			line := @pos->GetLine();
			start_pos := @pos->GetPos();
			end_pos := start_pos + @name->Size();

			buffer := "";
			each(i : depth) {
				buffer += '\t';
			};

			buffer += "[name={$@name}, kind={$kind}, line={$line}, start_pos={$start_pos}, end_pos={$end_pos}]";
			if(@children <> Nil) {
				each(i : @children) {
					child := @children->Get(i);
					buffer += '\n';
					buffer += child->ToString(depth + 1);
				};
			};

			return buffer;
		}
	}

	#~
	# Symbol
	#
	class Symbol {
		@name : String;
		@kind : Symbol->Kind;

		@start_line : Int;
		@start_index : Int;

		@end_line : Int;
		@end_index : Int;

		consts Kind {
			MODULE := 9,
			CLASS := 7,
			INTERFACE := 8,
			ENUM := 13,
			METHOD := 2,
			FUNCTION := 3,
			CONSTRUCTOR := 4,
			STRUCT := 22
		}

		New(kind : Symbol->Kind, name : String) {
			@kind := kind;
			@name := name;
		}

		method : public : SetStart(start_line : Int, start_index : Int) ~ Nil {
			@start_line := start_line;
			@start_index := start_index;
		}

		method : public : SetEnd(end_line : Int, end_index : Int) ~ Nil {
			@end_line := end_line;
			@end_index := end_index;
		}

		method : public : GetObj() ~ Data.JSON.JsonElement {
			builder := Data.JSON.JsonBuilder->New();
			
			obj := builder->PushObject();
			obj->Insert("kind", @kind->As(Int));
			obj->Insert("name", @name);
				builder->PushObject("location");

					builder->PushObject("range");
						obj := builder->PushObject("start");
						obj->Insert("line", @start_line);
						obj->Insert("character", @start_index);
						builder->Pop();

						obj := builder->PushObject("end");
						obj->Insert("line", @end_line);
						obj->Insert("character", @end_index);
						builder->Pop();
					builder->Pop();

					builder->PushObject("selectionRange");
						obj := builder->PushObject("start");
						obj->Insert("line", @start_line);
						obj->Insert("character", @start_index);
						builder->Pop();

						obj := builder->PushObject("end");
						obj->Insert("line", @end_line);
						obj->Insert("character", @end_index);
						builder->Pop();
					builder->Pop();

			doc := builder->PopAll();

			return doc;
		}
	}
	~#
}