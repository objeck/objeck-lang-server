use Collection.Generic;

bundle Data.Parser {
	#
	# Parser
	#
	class Parser {
		@text : String;
		@tokens : Vector<Token>;
		@token_index : Int;
		@findings : Vector<Finding>;

		New(file : String) {
			@text := System.IO.File.FileReader->ReadFile(file);
			@findings := Vector->New()<Finding>;
		}

#~ ~#
		function : Main(args : String[]) ~ Nil {
			timer := System.Time.Timer->New();
			timer->Start();			
			
			if(args->Size() = 1) {
				Parser->New(args[0])->Parse()->PrintLine();
			};

			timer->End();
			timer->GetElapsedTime()->PrintLine();
		}
#~ ~#
		
		method : public : Parse() ~ Bool {
			@tokens := Scanner->New(@text)->Scan()<Token>;
# Dump();

			ParseUses();
			return ParseClass();
		}

		method : ParseUses() ~ Bool {
			if(<>Match(Token->Type->USE_ID)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseClass() ~ Bool {
			if(<>Match(Token->Type->CLASS_ID)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
Dump(0);

			NextToken();

			if(<>Match(Token->Type->OCPN)) {
				return false;
			};
			NextToken();

			while(Match(Token->Type->FUNCTION_ID) | Match(Token->Type->METHOD_ID) | Match(Token->Type->IDENT)) {
				if(Match(Token->Type->FUNCTION_ID) | Match(Token->Type->METHOD_ID)) {
					if(<>ParseMethod()) {
						return false;
					};
				}
				else if(Match(Token->Type->IDENT)) {
					if(<>ParseDeclaration()) {
						return false;
					};

					if(<>Match(Token->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				};
			};

			return true;
		}

		method : ParseMethod() ~ Bool {
			NextToken();

			if(<>Match(Token->Type->COLON)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
Dump(2);			
			NextToken();

			# declarations
			if(<>ParseDeclarationParameters()) {
				return false;
			};

			if(<>Match(Token->Type->TILDE)) {
				return false;
			};
			NextToken();

			if(<>ParseType()) {
				return false;
			};

			if(<>Match(Token->Type->OCPN)) {
				return false;
			};
			NextToken();

			# statements
			if(<>ParseStatements()) {
				return false;
			};

			return true;
		}

		method : ParseDeclaration() ~ Bool {
			if(<>Match(Token->Type->IDENT)) {
				return false;
			};
Dump(1);
			NextToken();

			if(<>Match(Token->Type->COLON)) {
				return false;
			};
			NextToken();

			if(Match(Token->Type->STATIC_ID)) {
				NextToken();

				if(<>Match(Token->Type->COLON)) {
					return false;
				};
				NextToken();
			};
			
			if(<>ParseType()) {
				return false;
			};

			return true;
		}

		method : ParseDeclarationParameters() ~ Bool {
			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			while(<>Match(Token->Type->CPN)) {
				if(<>ParseDeclaration()) {
					return false;
				};

				if(Match(Token->Type->COLON)) {
					NextToken();
				};
			};
			NextToken();
			
			return true;
		}

		method : ParseStatements() ~ Bool {
			done := false;
			do {
				if(Match(Token->Type->IDENT)) {
Dump(3);

					NextToken();

					if(Match(Token->Type->ASSIGN)) {
						NextToken();

						if(<>ParseExpression()) {
							return false;
						};
					}
					else if(Match(Token->Type->OPN)) {
						if(<>ParseCallParameters()) {	
							return false;
						};
					}
					else {
						return false;
					};

					if(Match(Token->Type->SEMI_COLON) | Match(Token->Type->ASSESSOR)) {
						NextToken();
					};
				}
				else {
					done := true;
				};
			}
			while(<>done);

			return true;
		}

		method : ParseExpression() ~ Bool {
			select(GetType()) {
				label Token->Type->STRING_LIT
				label Token->Type->INT_LIT
				label Token->Type->FLOAT_LIT {
					NextToken();
					return true;
				}

				label Token->Type->IDENT {
					NextToken();

					if(Match(Token->Type->ASSESSOR)) {
						NextToken();

						if(<>Match(Token->Type->IDENT)) {
							return false;
						};
						NextToken();

						if(<>ParseCallParameters()) {
							return false;
						};
					};

					return true;
				}
			};

			return false;
		}

		method : ParseCallParameters() ~ Bool {
			if(<>Match(Token->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>Match(Token->Type->CPN)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseType() ~ Bool {
			select(GetType()) {
				label Token->Type->NIL_ID
				label Token->Type->STRING_ID
				label Token->Type->INT_ID
				label Token->Type->FLOAT_ID
				label Token->Type->CHAR_ID
				label Token->Type->BYTE_ID {
					NextToken();
				}

				label Token->Type->IDENT {
					NextToken();
				}

				other {
					return false;
				}
			};

			if(Match(Token->Type->OBR)) {
				while(Match(Token->Type->OBR)) {
					NextToken();

					if(<>Match(Token->Type->CBR)) {
						return false;
					};
					NextToken();
				};
			};

			return true;
		}

		method : NextToken() ~ Nil {
			if(@token_index < @tokens->Size()) {
				@token_index += 1;
			};
		}

		method : GetType() ~ Token->Type {
			if(@token_index < @tokens->Size()) {
				return @tokens->Get(@token_index)->GetType();
			};

			return Token->Type->EOS;
		}

		method : Match(type : Token->Type, offset : Int := 0) ~ Bool {
			index := @token_index + offset;
			if(index < @tokens->Size()) {
				return @tokens->Get(index)->GetType() = type;
			};

			return false;
		}

		method : Dump() ~ Nil {
			each(i : @tokens) {
				token := @tokens->Get(i);
				"{$i}: {$token}"->PrintLine();
			};
		}

		method : Dump(id : Int) ~ Nil {
			if(@token_index < @tokens->Size()) {
				token := @tokens->Get(@token_index);
				"--- {$id}: {$token} ---"->PrintLine();
			};
		}
	}

	class Finding {
		New() {
		}
	}

	#
	# Scanner
	#
	class : private : Scanner {
		@tokens : Vector<Token>;
		@buffer : Char[];
		@buffer_index : Int;
		@cur_char : Char;
		@next_char : Char;
		@line_num : Int;
		@line_index : Int;
		@keywords : Hash<String, IntHolder>;

		New(text : String) {
			@buffer := text->ToCharArray();
			@buffer_index := 0;

			@tokens := Vector->New()<Token>;
			@keywords := Hash->New()<String, IntHolder>;
			@keywords->Insert("class", IntHolder->New(Type->CLASS_ID));
			@keywords->Insert("use", IntHolder->New(Type->USE_ID));
			@keywords->Insert("enum", IntHolder->New(Type->ENUM_ID));
			@keywords->Insert("bundle", IntHolder->New(Type->BUNDLE_ID));
			@keywords->Insert("consts", IntHolder->New(Type->CONSTS_ID));
			@keywords->Insert("function", IntHolder->New(Type->FUNCTION_ID));
			@keywords->Insert("method", IntHolder->New(Type->METHOD_ID));
			@keywords->Insert("public", IntHolder->New(Type->PUBLIC_ID));
			@keywords->Insert("private", IntHolder->New(Type->PRIVATE_ID));
			@keywords->Insert("native", IntHolder->New(Type->NATIVE_ID));
			@keywords->Insert("static", IntHolder->New(Type->STATIC_ID));
			@keywords->Insert("Nil", IntHolder->New(Type->NIL_ID));
			@keywords->Insert("String", IntHolder->New(Type->STRING_ID));
			@keywords->Insert("Int", IntHolder->New(Type->INT_ID));
			@keywords->Insert("Float", IntHolder->New(Type->FLOAT_ID));
			@keywords->Insert("Char", IntHolder->New(Type->CHAR_ID));
			@keywords->Insert("Byte", IntHolder->New(Type->BYTE_ID));
		}

		method : NextChar() ~ Nil {
			if(@buffer_index + 1 < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;
				@next_char := @buffer[@buffer_index];
			}
			else if(@buffer_index < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;				
				@next_char := '\0';
			}
			else {
				@cur_char := @next_char := '\0';
			};
		}

		method : Whitespace() ~ Nil {
			while(@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n') {
				if(@cur_char = '\n') {
					@line_num += 1;
					@line_index := 0;
				};

				NextChar();
			};
		}

		method : Comment() ~ Nil {
			if(@cur_char = '#') {
				NextChar();

				if(@cur_char = '~') {
					NextChar();
					while(<>(@cur_char = '~' & @next_char = '#')) {
						if(@cur_char = '\n') {
							@line_num += 1;
						};
						NextChar();
					};
					NextChar();
					NextChar();
				}
				else {
					while(@cur_char <> '\n') {
						NextChar();
					};
					@line_num += 1;
					NextChar();
				};

				Whitespace();
			};
		}

		method : ParseIdentifier() ~ Nil {
			start := @buffer_index;
			start_index := @line_index - 1;

			while(@cur_char->IsChar() | @cur_char->IsDigit() | @cur_char = '.' | @cur_char = '_' | @cur_char = '@') {
				NextChar();
			};
			ident := String->New(@buffer, start - 1, @buffer_index - start);

			found := @keywords->Find(ident);
			if(found <> Nil) {
				type := found->Get()->As(Token->Type);
				@tokens->AddBack(Token->New(type, ident, @line_num, start_index));
			}
			else {
				@tokens->AddBack(Token->New(Token->Type->IDENT, ident, @line_num, start_index));
			};
		}

		method : ParseNumber() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			is_float := false;
			while(@cur_char->IsDigit() | @cur_char = '.' | @cur_char = 'u' | @cur_char = 'x') {
				if(@cur_char = '.') {
					is_float := true;
				};

				NextChar();
			};

			ident := String->New(@buffer, start - 1, @buffer_index - start);
			if(is_float) {
				@tokens->AddBack(Token->New(ident->ToFloat(), @line_num, start_index));
			}
			else {
				@tokens->AddBack(Token->New(ident->ToInt(), @line_num, start_index));
			};
		}

		method : ParseString() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			do {
				NextChar();
			}
			while(@cur_char <> '"');

			ident := String->New(@buffer, start, @buffer_index - start - 1);
			NextChar();

			@tokens->AddBack(Token->New(Token->Type->STRING_LIT, ident, @line_num, start_index));
		}

		method : ParseChar() ~ Nil {
			NextChar();

			if(@cur_char = '\\') {
				select(@cur_char) {
					label 'r' {

					}

					label 'n' {
						
					}
				};
			}
			else {

			};

			NextChar();
		}

		method : public : Scan() ~ Vector<Token> {
			NextChar();

			while(@cur_char <> '\0') {
				Whitespace();
				Comment();

				if(@cur_char->IsChar() | @cur_char = '@' | @cur_char = '_') {
					ParseIdentifier();
				}
				else if(@cur_char->IsDigit()) {
					ParseNumber();
				}
				else if(@cur_char = '"') {
					ParseString();
				}
				else if(@cur_char = '\'') {
					ParseChar();
				}
				else {
					select(@cur_char) {
						label '<' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->LES_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->LES, @line_num, start_index));
								NextChar();
							};
						}

						label '>' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->GTR_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->GTR, @line_num, start_index));
								NextChar();
							};
						}

						label ';' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->SEMI_COLON, @line_num, start_index));
							NextChar();
						}

						label ',' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->COMMA, @line_num, start_index));
							NextChar();
						}

						label '{' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OCPN, @line_num, start_index));
							NextChar();
						}

						label '}' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CCPN, @line_num, start_index));
							NextChar();
						}

						label '(' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OPN, @line_num, start_index));
							NextChar();
						}

						label ')' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CPN, @line_num, start_index));
							NextChar();
						}

						label '=' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->EQL, @line_num, start_index));
							NextChar();
						}

						label ':' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ASSIGN, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->COLON, @line_num, start_index));
								NextChar();
							};
						}

						label '~' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->TILDE, @line_num, start_index));
							NextChar();
						}

						label '[' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OBR, @line_num, start_index));
							NextChar();
						}

						label ']' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CBR, @line_num, start_index));
							NextChar();
						}

						label '+' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->ADD, @line_num, start_index));
							NextChar();
						}
						
						label '*' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->MUL, @line_num, start_index));
							NextChar();
						}

						label '/' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->DIV, @line_num, start_index));
							NextChar();
						}

						label '%' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->MOD, @line_num, start_index));
							NextChar();
						}

						label '-' {
							if(@next_char = '>') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->ASSESSOR, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(Token->New(Token->Type->SUB, @line_num, start_index));
								NextChar();
							};
						}

						label '→' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->ASSESSOR, @line_num, start_index));
							NextChar();
						}

						label '\0' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->EOS, @line_num, start_index));
							NextChar();
						}

						other {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OTHER, @cur_char, @line_num, start_index));
						}
					};
				};
			};

			@tokens->AddBack(Token->New(Token->Type->EOS, @line_num, 0));
			return @tokens;
		}
	}

	class : private : Token {
		@type : Token->Type;
		@line_num : Int;
		@line_index : Int;
		@str_value : String;
		@int_value : Int;
		@float_value : Float;
		@char_value : Char;

		enum Type {
			OTHER,
			EOS,
			IDENT,
			STRING_LIT,
			INT_LIT,
			FLOAT_LIT,
			CHAR_LIT,
			LES,
			GTR,
			LES_EQL,
			GTR_EQL,
			SEMI_COLON,
			EQL,
			ADD,
			SUB,
			MUL,
			DIV,
			MOD,
			COLON,
			COMMA,
			TILDE,
			OPN,
			CPN,
			OCPN,
			CCPN,
			OBR,
			CBR,
			ASSESSOR,
			ASSIGN,
			CLASS_ID,
			USE_ID,
			ENUM_ID,
			CONSTS_ID,
			FUNCTION_ID,
			METHOD_ID,
			PUBLIC_ID,
			PRIVATE_ID,
			BUNDLE_ID,
			NATIVE_ID,
			STATIC_ID,
			NIL_ID,
			STRING_ID,
			INT_ID,
			FLOAT_ID,
			CHAR_ID,
			BYTE_ID
		}

		New(type : Token->Type, line_num : Int, line_index : Int) {
			@type := type;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, str_value : String, line_num : Int, line_index : Int) {
			@type := type;
			@str_value := str_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(int_value : Int, line_num : Int, line_index : Int) {
			@type := Token->Type->INT_LIT;
			@int_value := int_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(float_value : Float, line_num : Int, line_index : Int) {
			@type := Token->Type->FLOAT_LIT;
			@float_value := float_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(char_value : Char, line_num : Int, line_index : Int) {
			@type := Token->Type->CHAR_LIT;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, char_value : Char, line_num : Int, line_index : Int) {
			@type := type;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		method : public : GetType() ~ Token->Type {
			return @type;
		}

		method : public : GetLine() ~ Int {
			return @line_num;
		}

		method : public : GetPos() ~ Int {
			return @line_index;
		}

		method : public : GetStringValue() ~ String {
			return @str_value;
		}

		method : public : GetIntValue() ~ Int {
			return @int_value;
		}

		method : public : GetFloatValue() ~ Float {
			return @float_value;
		}

		method : public : GetCharValue() ~ Char {
			return @char_value;
		}

		method : public : ToString() ~ String {
			buffer := "type=";

			select(@type) {
				label Token->Type->IDENT {
					buffer += "IDENT, value='{$@str_value}'";
				}

				label Token->Type->STRING_LIT {
					buffer += "STRING_LIT, value='{$@str_value}'";
				}

				label Token->Type->INT_LIT {
					buffer += "INT_LIT, value={$@int_value}";
				}
				
				label Token->Type->FLOAT_LIT {
					buffer += "FLOAT_LIT, value={$@float_value}";
				}
				
				label Token->Type->CHAR_LIT {
					buffer += "CHAR_LIT, value='{$@char_value}'";
				}

				label Token->Type->ASSESSOR {
					buffer += "ASSESSOR";
				}

				label Token->Type->SEMI_COLON {
					buffer += "SEMI_COLON";
				}

				label Token->Type->LES {
					buffer += "LES";
				}

				label Token->Type->LES_EQL {
					buffer += "LES_EQL";
				}

				label Token->Type->GTR_EQL {
					buffer += "GTR_EQL";
				}

				label Token->Type->GTR {
					buffer += "GTR";
				}

				label Token->Type->ENUM_ID {
					buffer += "ENUM_ID";
				}

				label Token->Type->CONSTS_ID {
					buffer += "CONSTS_ID";
				}

				label Token->Type->EQL {
					buffer += "EQL";
				}

				label Token->Type->ADD {
					buffer += "ADD";
				}

				label Token->Type->SUB {
					buffer += "SUB";
				}

				label Token->Type->MUL {
					buffer += "MUL";
				}

				label Token->Type->DIV {
					buffer += "DIV";
				}

				label Token->Type->MOD {
					buffer += "MOD";
				}

				label Token->Type->ASSIGN {
					buffer += "ASSIGN";
				}

				label Token->Type->FUNCTION_ID {
					buffer += "FUNCTION_ID";
				}

				label Token->Type->METHOD_ID {
					buffer += "METHOD_ID";
				}

				label Token->Type->CLASS_ID {
					buffer += "CLASS_ID";
				}

				label Token->Type->USE_ID {
					buffer += "USE_ID";
				}

				label Token->Type->PUBLIC_ID {
					buffer += "PUBLIC_ID";
				}

				label Token->Type->PRIVATE_ID {
					buffer += "PRIVATE_ID";
				}

				label Token->Type->BUNDLE_ID {
					buffer += "BUNDLE_ID";
				}

				label Token->Type->NATIVE_ID {
					buffer += "NATIVE_ID";
				}

				label Token->Type->STATIC_ID {
					buffer += "STATIC_ID";
				}

				label Token->Type->NIL_ID {
					buffer += "NIL_ID";
				}

				label Token->Type->STRING_ID {
					buffer += "STRING_ID";
				}

				label Token->Type->INT_ID {
					buffer += "INT_ID";
				}

				label Token->Type->FLOAT_ID {
					buffer += "FLOAT_ID";
				}

				label Token->Type->CHAR_ID {
					buffer += "CHAR_ID";
				}

				label Token->Type->BYTE_ID {
					buffer += "BYTE_ID";
				}

				label Token->Type->COLON {
					buffer += "COLON";
				}
				
				label Token->Type->COMMA {
					buffer += "COMMA";
				}
				
				label Token->Type->TILDE {
					buffer += "TILDE";
				}
				
				label Token->Type->OCPN {
					buffer += "OCPN";
				}
				
				label Token->Type->CCPN {
					buffer += "CCPN";
				}

				label Token->Type->OPN {
					buffer += "OPN";
				}
				
				label Token->Type->CPN {
					buffer += "CPN";
				}

				label Token->Type->OBR {
					buffer += "OBR";
				}

				label Token->Type->CBR {
					buffer += "CBR";
				}
				
				label Token->Type->OTHER {
					id := @char_value->As(Int);
					buffer += "OTHER: id={$id}, value='{$@char_value}'";
				}
			};
			buffer += ", line={$@line_num}, pos={$@line_index}";

			return buffer;
		}
	}
}