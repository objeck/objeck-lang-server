use Collection.Generic;

bundle Data.Parser {
	#
	# Parser
	#
	class Parser {
		
		#--- start testing ---
		function : Main(args : String[]) ~ Nil {
			text := System.IO.File.FileReader->ReadFile(args[0]);
# text->PrintLine();			
			tokens := Scanner->New(text)->Scan()<Token>;
			each(i : tokens) {
				token := tokens->Get(i);
				token->ToString()->PrintLine();
			};
		}

		function : EscapeText(text : String) ~ String {
			buffer := "";

			each(i : text) {
				char := text->Get(i);

				select(char) {
					label '\r' {
						buffer += "\\r";
					}

					label '\n' {
						buffer += "\\n";
					}

					label '\t' {
						buffer += "\\t";
					}

					other {
						buffer += char;
					}
				};
			};

			return buffer;
		}

		#--- end testing ---

		method : public : Parse() ~ Bool {
			return false;
		}
	}

	class : private : TreeNode {
		New() {
		}
	}

	#
	# Scanner
	#
	class : private : Scanner {
		@tokens : Vector<Token>;
		@buffer : Char[];
		@buffer_index : Int;
		@cur_char : Char;
		@next_char : Char;
		@line_num : Int;
		@line_index : Int;

		New(text : String) {
			@buffer := text->ToCharArray();
			@buffer_index := 0;
			@tokens := Vector->New()<Token>;	
		}

		method : NextChar() ~ Nil {
			if(@buffer_index + 1 < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;
				@next_char := @buffer[@buffer_index];
			}
			else if(@buffer_index < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;				
				@next_char := '\0';
			}
			else {
				@cur_char := @next_char := '\0';
			};
		}

		method : Whitespace() ~ Nil {
			while(@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n') {
				if(@cur_char = '\n') {
					@line_num += 1;
					@line_index := 0;
				};

				NextChar();
			};
		}

		method : Identifier() ~ Nil {
			start := @buffer_index;
			start_index := @line_index - 1;

			while(@cur_char->IsChar() | @cur_char->IsDigit() | @cur_char = '.' | @cur_char = '_' | @cur_char = '@') {
				NextChar();
			};

			ident := String->New(@buffer, start - 1, @buffer_index - start);
			@tokens->AddBack(Token->New(Token->Type->IDENT, ident, @line_num, start_index));
		}

		method : Number() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			is_float := false;
			while(@cur_char->IsDigit() | @cur_char = '.' | @cur_char = 'u' | @cur_char = 'x') {
				if(@cur_char = '.') {
					is_float := true;
				};

				NextChar();
			};

			ident := String->New(@buffer, start - 1, @buffer_index - start);
			if(is_float) {
				@tokens->AddBack(Token->New(Token->Type->IDENT, ident->ToInt(), @line_num, start_index));
			}
			else {
				@tokens->AddBack(Token->New(Token->Type->IDENT, ident->ToFloat(), @line_num, start_index));
			};
		}

		method : public : Scan() ~ Vector<Token> {
			NextChar();

			# --- while ---
			each(i : 20) {
				Whitespace();

				if(@cur_char->IsChar() | @cur_char = '@' | @cur_char = '_') {
					Identifier();
				}
				else if(@cur_char->IsDigit()) {
					Number();
				}
				else {
					select(@cur_char) {
						label ';' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->SEMI_COLON, @line_num, start_index));
							NextChar();
						}

						label ',' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->COMMA, @line_num, start_index));
							NextChar();
						}

						label '{' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OPN, @line_num, start_index));
							NextChar();
						}

						label '}' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->CPN, @line_num, start_index));
							NextChar();
						}

						label ':' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->COLON, @line_num, start_index));
							NextChar();
						}

						label '~' {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->TILDE, @line_num, start_index));
							NextChar();
						}

						other {
							start_index := @line_index - 1;
							@tokens->AddBack(Token->New(Token->Type->OTHER, @cur_char, @line_num, start_index));
						}
					};
				};
			};

			return @tokens;
		}
	}

	class : private : Token {
		@type : Token->Type;
		@line_num : Int;
		@line_index : Int;
		@str_value : String;
		@int_value : Int;
		@float_value : Float;
		@char_value : Char;

		enum Type {
			IDENT,
			INT,
			FLOAT,
			CHAR,
			SEMI_COLON,
			COLON,
			COMMA,
			TILDE,
			OPN,
			CPN,
			OTHER
		}

		New(type : Token->Type, line_num : Int, line_index : Int) {
			@type := type;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, str_value : String, line_num : Int, line_index : Int) {
			@type := type;
			@str_value := str_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, int_value : Int, line_num : Int, line_index : Int) {
			@type := type;
			@int_value := int_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, float_value : Float, line_num : Int, line_index : Int) {
			@type := type;
			@float_value := float_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : Token->Type, char_value : Char, line_num : Int, line_index : Int) {
			@type := type;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		method : public : GetStringValue() ~ String {
			return @str_value;
		}

		method : public : GetIntValue() ~ Int {
			return @int_value;
		}

		method : public : GetFloatValue() ~ Float {
			return @float_value;
		}

		method : public : GetCharValue() ~ Char {
			return @char_value;
		}

		method : public : ToString() ~ String {
			buffer := "type=";

			select(@type) {
				label Token->Type->IDENT {
					buffer += "IDENT, value='{$@str_value}'";
				}

				label Token->Type->INT {
					buffer += "INT, value={$@int_value}";
				}
				
				label Token->Type->FLOAT {
					buffer += "FLOAT, value={$@float_value}";
				}
				
				label Token->Type->CHAR {
					buffer += "CHAR, value='{$@char_value}'";
				}
				
				label Token->Type->SEMI_COLON {
					buffer += "SEMI_COLON";
				}
				
				label Token->Type->COLON {
					buffer += "ICOLONNT";
				}
				
				label Token->Type->COMMA {
					buffer += "COMMA";
				}
				
				label Token->Type->TILDE {
					buffer += "TILDE";
				}
				
				label Token->Type->OPN {
					buffer += "OPN";
				}
				
				label Token->Type->CPN {
					buffer += "CPN";
				}
				
				label Token->Type->OTHER {
					buffer += "OTHER";
				}
			};
			buffer += ", line={$@line_num}, line_pos={$@line_index}";

			return buffer;
		}
	}
}