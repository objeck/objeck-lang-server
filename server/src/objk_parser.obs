use Collection.Generic;
use Data.JSON;

bundle LSP {
	#
	# Parser
	#
	class Parser {
		@text : String;
		@tokens : Vector<ScannerToken>;
		@token_index : Int;
		@symbol_scope : Stack<Entity>;
		@entities : Entity;

		@diagnose_start : ScannerToken;
		@diagnose_end : ScannerToken;

		New(text : String) {
			@text := text;
			@symbol_scope := Stack->New()<Entity>;
		}

#~
		function : Main(args : String[]) ~ Nil {
			timer := System.Time.Timer->New();
			timer->Start();			
			
			if(args->Size() = 1) {
				parser := Parser->New(System.IO.File.FileReader->ReadFile(args[0]));
				parser->Parse()->PrintLine();
#				if(parser->Parse()) {

					result := parser->GetDiagnoses("");
					"Result = {$result}"->PrintLine();
#				};
			};

			timer->End();
			timer->GetElapsedTime()->PrintLine();
		}
~#

		method : public : GetSymbols() ~ JsonElement {
			return @entities->GetSymbols();
		}

		method : public : GetReferences(find : String, uri : String) ~ JsonElement {
			return @entities->GetReferences(find, uri);
		}

		method : public : GetDiagnoses(uri : String) ~ JsonElement {
			diagnostics := JsonElement->New(JsonElement->JsonType->ARRAY);

			if(@diagnose_start <> Nil) {
				start_line := @diagnose_start->GetLine();
				start_index := @diagnose_start->GetPos();
				
				end_line := @diagnose_end->GetLine();
				end_index := @diagnose_end->GetPos();

				each(i : 1) {
					diagnostic := JsonElement->New(JsonElement->JsonType->OBJECT);

					diagnostic->Insert("severity", 1);
					diagnostic->Insert("message", "Unexpected token");
					diagnostic->Insert("source", "objk-linter");

					range := JsonElement->New(JsonElement->JsonType->OBJECT);
					# start
					start := JsonElement->New(JsonElement->JsonType->OBJECT);
					start->Insert("line", start_line);
					start->Insert("character", start_index);
					range->Insert("start", start);
					# end
					end := JsonElement->New(JsonElement->JsonType->OBJECT);
					end->Insert("line", start_line);
					end->Insert("character", end_index);
					range->Insert("end", end);
					diagnostic->Insert("range", range);
					
					diagnostics->Add(diagnostic);
				};
			};
			
			request := JsonElement->New(JsonElement->JsonType->OBJECT);
			request->Insert("uri", uri);
			request->Insert("diagnostics", diagnostics);
			
			return request;
		}

		method : public : Parse() ~ Bool {
			@tokens := Scanner->New(@text)->Scan()<ScannerToken>;
# DumpTokens();

			result := ParseUses();
			if(<>result) {
				@diagnose_start := GetToken();
				@diagnose_end := GetToken(1);
				return false;
			};

			result := ParseClass();
			if(<>result) {
				@diagnose_start := GetToken();
				@diagnose_end := GetToken(1);
				return false;
			};

			return true;
		}

		method : ParseUses() ~ Bool {
			if(Match(ScannerToken->Type->USE_ID)) {
				while(Match(ScannerToken->Type->USE_ID)) {					
					NextToken();

					if(<>Match(ScannerToken->Type->IDENT)) {
						return false;
					};
					NextToken();

					if(<>Match(ScannerToken->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				};
			};

			return true;
		}

		method : ParseClass() ~ Bool {
			if(<>Match(ScannerToken->Type->CLASS_ID)) {
				return false;
			};
			NextToken();

			if(<>Match(ScannerToken->Type->IDENT)) {
				return false;
			};
			symbol := Entity->New(GetToken()->GetStringValue(), Entity->Kind->CLASS_SYM);
			symbol->SetStart(GetToken());
			@symbol_scope->Push(symbol);
			NextToken();

			if(<>Match(ScannerToken->Type->OCPN)) {
				return false;
			};
			NextToken();

			done := false;
			do {
				if(Match(ScannerToken->Type->FUNCTION_ID) | Match(ScannerToken->Type->METHOD_ID)) {
					if(<>ParseMethod(Match(ScannerToken->Type->FUNCTION_ID))) {
						return false;
					};
				}
				else if(Match(ScannerToken->Type->IDENT)) {
					if(<>ParseDeclaration()) {
						return false;
					};

					if(<>Match(ScannerToken->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else {
					done := true;
				};
			}
			while(<>done);

			if(<>Match(ScannerToken->Type->CCPN)) {
				return false;
			};
			NextToken();

			@entities := @symbol_scope->Pop();

			return true;
		}

		method : ParseMethod(is_func : Bool) ~ Bool {
			NextToken();

			if(<>Match(ScannerToken->Type->COLON)) {
				return false;
			};
			NextToken();

			if(Match(ScannerToken->Type->NATIVE_ID)) {
				NextToken();

				if(<>Match(ScannerToken->Type->COLON)) {
					return false;
				};
				NextToken();
			};

			if(<>Match(ScannerToken->Type->IDENT)) {
				return false;
			};
			parent := @symbol_scope->Top();
			
			child : Entity;
			if(is_func) {
				child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->FUNCTION_SYM);
			}
			else {
				child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->METHOD_SYM);
			};
			child->SetStart(GetToken());

			parent->AddChild(child);
			@symbol_scope->Push(child);
			NextToken();

			# declarations
			if(<>ParseDeclarationParameters()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->TILDE)) {
				return false;
			};
			NextToken();

			if(<>ParseType()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->OCPN)) {
				return false;
			};
			NextToken();

			# statements
			if(<>ParseStatements()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->CCPN)) {
				return false;
			};
			NextToken();

			@symbol_scope->Pop();

			return true;
		}

		method : ParseDeclaration() ~ Bool {
			if(<>Match(ScannerToken->Type->IDENT)) {
				return false;
			};

			parent := @symbol_scope->Top();
			child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
			child->SetStart(GetToken());
			parent->AddChild(child);
			NextToken();

			if(<>Match(ScannerToken->Type->COLON)) {
				return false;
			};
			NextToken();

			if(Match(ScannerToken->Type->STATIC_ID)) {
				NextToken();

				if(<>Match(ScannerToken->Type->COLON)) {
					return false;
				};
				NextToken();
			};
			
			if(<>ParseType()) {
				return false;
			};

			return true;
		}

		method : ParseDeclarationParameters() ~ Bool {
			if(<>Match(ScannerToken->Type->OPN)) {
				return false;
			};
			NextToken();

			while(<>Match(ScannerToken->Type->CPN)) {
				if(<>ParseDeclaration()) {
					return false;
				};

				if(Match(ScannerToken->Type->ASSIGN)) {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				};

				if(Match(ScannerToken->Type->COMMA)) {
					NextToken();
				};
			};
			NextToken();
			
			return true;
		}

		method : ParseStatements() ~ Bool {
			done := false;

			do {
				if(Match(ScannerToken->Type->IDENT) & Match(ScannerToken->Type->COLON, 1)) {
					if(<>ParseAssignmentDeclaration()) {
						return false;
					};
				}
				else if(Match(ScannerToken->Type->IDENT) | Match(ScannerToken->Type->STRING_LIT)) {
					if(<>ParseSimpleStatement()) {
						return false;
					};

				}
				else if(Match(ScannerToken->Type->RETURN_ID)) {
					if(<>ParseReturn()) {
						return false;
					};
				}
				else if(Match(ScannerToken->Type->EACH_ID)) {
					if(<>ParseEach()) {
						return false;
					};
				}
				else if(Match(ScannerToken->Type->FOR_ID)) {
					if(<>ParseFor()) {
						return false;
					};
				}
				else if(Match(ScannerToken->Type->IF_ID)) {
					if(<>ParseIfWhile()) {
						return false;
					};

					while(Match(ScannerToken->Type->ELSE_ID)) {
						if(Match(ScannerToken->Type->IF_ID, 1)) {
							NextToken();
						};

						if(<>ParseBody()) {
							return false;
						};

					};
					
					if(<>Match(ScannerToken->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else if(Match(ScannerToken->Type->WHILE_ID)) {
					if(<>ParseIfWhile()) {
						return false;
					};

					if(<>Match(ScannerToken->Type->SEMI_COLON)) {
						return false;
					};
					NextToken();
				}
				else {
					done := true;
				};
			}
			while(<>done);

			return true;
		}

		method : ParseSimpleStatement() ~ Bool {
			if(Match(ScannerToken->Type->IDENT)) {
				parent := @symbol_scope->Top();
				child : Entity;
				if(Match(ScannerToken->Type->OPN, 1)) {
					child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->FUNCTION_REF, parent);
				}
				else {
					child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
				};
				child->SetStart(GetToken());
				parent->AddChild(child);
			};

			NextToken();

			select(GetType()) {
				label ScannerToken->Type->ASSIGN
				label ScannerToken->Type->ADD_EQL
				label ScannerToken->Type->SUB_EQL
				label ScannerToken->Type->MUL_EQL
				label ScannerToken->Type->DIV_EQL {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				}
				
				label ScannerToken->Type->OPN {
					if(<>ParseCallParameters()) {	
						return false;
					};
				}

				label ScannerToken->Type->ASSESSOR {
					NextToken();
				}

				other { 
					return false;
				}
			};

			if(Match(ScannerToken->Type->SEMI_COLON) | Match(ScannerToken->Type->ASSESSOR)) {
				NextToken();
			};

			return true;
		}

		method : ParseAssignmentDeclaration() ~ Bool {
			if(<>ParseDeclaration()) {
				return false;
			};

			if(Match(ScannerToken->Type->ASSIGN)) {
				NextToken();

				if(<>ParseExpression()) {
					return false;
				};
			};

			if(<>Match(ScannerToken->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseIfWhile() ~ Bool {
			NextToken();

			if(<>Match(ScannerToken->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->CPN)) {
				return false;
			};
			
			return ParseBody();
		}

		method : ParseFor() ~ Bool {
			NextToken();

			if(<>Match(ScannerToken->Type->OPN)) {
				return false;
			};
			NextToken();

			if(Match(ScannerToken->Type->IDENT) & Match(ScannerToken->Type->COLON, 1)) {
				if(<>ParseAssignmentDeclaration()) {
					return false;
				};
			}
			else if(Match(ScannerToken->Type->IDENT)) {
				if(<>ParseSimpleStatement()) {
					return false;
				};
			}
			else {
				return false;
			};

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			if(<>ParseSimpleStatement()) {
				return false;
			};
						
			if(<> ParseBody()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}
		
		method : ParseEach() ~ Bool {
			NextToken();

			if(<>Match(ScannerToken->Type->OPN)) {
				return false;
			};
			NextToken();

			if(<>Match(ScannerToken->Type->IDENT)) {
				return false;
			};

			parent := @symbol_scope->Top();
			child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
			child->SetStart(GetToken());
			parent->AddChild(child);
			NextToken();

			if(<>Match(ScannerToken->Type->COLON)) {
				return false;
			};
			NextToken();

			if(<>Match(ScannerToken->Type->IDENT)) {
				return false;
			};

			parent := @symbol_scope->Top();
			child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
			child->SetStart(GetToken());
			parent->AddChild(child);
			NextToken();

			if(<>Match(ScannerToken->Type->CPN)) {
				return false;
			};
			
			if(<>ParseBody()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseBody() ~ Bool {
			NextToken();

			# statements
			if(<>Match(ScannerToken->Type->OCPN)) {
				return false;
			};
			NextToken();

			if(<>ParseStatements()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->CCPN)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseExpression() ~ Bool {
			done := false;

			do {
				if(<>ParseSimpleExpression()) {
					return false;
				};

				select(GetType()) {
					label ScannerToken->Type->AND
					label ScannerToken->Type->OR
					label ScannerToken->Type->EQL
					label ScannerToken->Type->NEQL
					label ScannerToken->Type->LES
					label ScannerToken->Type->GTR
					label ScannerToken->Type->LES_EQL
					label ScannerToken->Type->GTR_EQL
					label ScannerToken->Type->ADD
					label ScannerToken->Type->SUB
					label ScannerToken->Type->MUL
					label ScannerToken->Type->DIV
					label ScannerToken->Type->MOD {
						NextToken();
					}

					other {
						done := true;
					}
				};
			}
			while(<>done);

			return true;
		}

		method : ParseSimpleExpression() ~ Bool {
			select(GetType()) {
				label ScannerToken->Type->STRING_LIT
				label ScannerToken->Type->CHAR_LIT
				label ScannerToken->Type->INT_LIT
				label ScannerToken->Type->FLOAT_LIT {
					NextToken();

					return true;
				}

				label ScannerToken->Type->IDENT {
					parent := @symbol_scope->Top();
					child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
					child->SetStart(GetToken());
					parent->AddChild(child);
					NextToken();
					
					if(Match(ScannerToken->Type->ASSESSOR)) {
						while(Match(ScannerToken->Type->ASSESSOR)) {
							NextToken();

							if(Match(ScannerToken->Type->IDENT)) {
								parent := @symbol_scope->Top();
								child : Entity;
								if(GetToken()->GetStringValue()->Equals("New")) {
									child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->CONSTRUCTOR_REF, parent);
								}
								else if(Match(ScannerToken->Type->OPN, 1)) {
									child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->FUNCTION_REF, parent);
								}
								else {
									child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
								};
								child->SetStart(GetToken());
								parent->AddChild(child);
								NextToken();

								if(Match(ScannerToken->Type->OPN)) {
									if(<>ParseCallParameters()) {
										return false;
									};
								};
							}
							else if(Match(ScannerToken->Type->AS_ID)) {
								NextToken();

								if(<>Match(ScannerToken->Type->OPN)) {
									return false;
								};
								NextToken();

								if(<>ParseType()) {
									return false;
								};

								if(<>Match(ScannerToken->Type->CPN)) {
									return false;
								};
								NextToken();
							};
						};
					}
					else if(Match(ScannerToken->Type->OPN)) {
						if(<>ParseCallParameters()) {
							return false;
						};
					}
					else if(Match(ScannerToken->Type->OBR)) {
						NextToken();

						if(<>ParseExpression()) {
							return false;
						};

						if(<>Match(ScannerToken->Type->CBR)) {
							return false;
						};
						NextToken();
					};

					return true;
				}

				label ScannerToken->Type->NIL_ID {
					NextToken();

					return true;
				}

				label ScannerToken->Type->INT_ID
				label ScannerToken->Type->FLOAT_ID
				label ScannerToken->Type->CHAR_ID
				label ScannerToken->Type->BYTE_ID {
					NextToken();

					if(<>Match(ScannerToken->Type->ASSESSOR)) {
						return false;
					};
					NextToken();

					if(Match(ScannerToken->Type->IDENT)) {
						parent := @symbol_scope->Top();
						child : Entity;
						if(Match(ScannerToken->Type->OPN, 1)) {
							child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->FUNCTION_REF, parent);
						}
						else {
							child := Entity->New(GetToken()->GetStringValue(), Entity->Kind->VARIABLE_REF, parent);
						};
						child->SetStart(GetToken());
						parent->AddChild(child);
						NextToken();

						if(<>ParseCallParameters()) {
							return false;
						};
					};

					return true;
				}

				label ScannerToken->Type->OPN {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};

					if(<>Match(ScannerToken->Type->CPN)) {
						return false;
					};
					NextToken();

					return true;	
				}
			};

			return false;
		}

		method : ParseCallParameters() ~ Bool {
			if(<>Match(ScannerToken->Type->OPN)) {
				return false;
			};
			NextToken();

			while(<>Match(ScannerToken->Type->CPN)) {
				if(<>ParseExpression()) {
					return false;
				};

				if(Match(ScannerToken->Type->COMMA)) {
					NextToken();

					if(<>ParseExpression()) {
						return false;
					};
				};
			};

			if(<>Match(ScannerToken->Type->CPN)) {
				return false;
			};
			NextToken();

			while(Match(ScannerToken->Type->LES)) {
				NextToken();
				if(<>ParseType()) {
					return false;
				};

				if(<>Match(ScannerToken->Type->GTR)) {
					return false;
				};
				NextToken();
			};

			return true;
		}

		method : ParseReturn() ~ Bool {
			NextToken();

			if(<>ParseExpression()) {
				return false;
			};

			if(<>Match(ScannerToken->Type->SEMI_COLON)) {
				return false;
			};
			NextToken();

			return true;
		}

		method : ParseType() ~ Bool {
			select(GetType()) {
				label ScannerToken->Type->NIL_ID
				label ScannerToken->Type->STRING_ID
				label ScannerToken->Type->INT_ID
				label ScannerToken->Type->FLOAT_ID
				label ScannerToken->Type->CHAR_ID
				label ScannerToken->Type->BYTE_ID {
					NextToken();
				}

				label ScannerToken->Type->IDENT {
					NextToken();
				}

				other {
					return false;
				}
			};

			if(Match(ScannerToken->Type->OBR)) {
				NextToken();

				while(Match(ScannerToken->Type->COMMA)) {
					NextToken();
				};

				if(<>Match(ScannerToken->Type->CBR)) {
					return false;
				};
				NextToken();
			};

			return true;
		}

		method : NextToken() ~ Nil {
			if(@token_index < @tokens->Size()) {
				@token_index += 1;
			};
		}

		method : GetType() ~ ScannerToken->Type {
			if(@token_index < @tokens->Size()) {
				return @tokens->Get(@token_index)->GetType();
			};

			return ScannerToken->Type->EOS;
		}

		method : GetToken(offset : Int := 0) ~ ScannerToken {
			if(@token_index + offset < @tokens->Size()) {
				return @tokens->Get(@token_index + offset);
			};

			return Nil;
		}

		method : Match(type : ScannerToken->Type, offset : Int := 0) ~ Bool {
			index := @token_index + offset;
			if(index < @tokens->Size()) {
				return @tokens->Get(index)->GetType() = type;
			};

			return false;
		}

		method : DumpTokens() ~ Nil {
			each(i : @tokens) {
				token := @tokens->Get(i);
				"{$i}: {$token}"->PrintLine();
			};
		}

		method : Dump(id : Int) ~ Nil {
			if(@token_index < @tokens->Size()) {
				token := @tokens->Get(@token_index);
				"--- {$id}: {$token} ---"->PrintLine();
			};
		}
	}

	#
	# Scanner
	#
	class : private : Scanner {
		@tokens : Vector<ScannerToken>;
		@buffer : Char[];
		@buffer_index : Int;
		@cur_char : Char;
		@next_char : Char;
		@line_num : Int;
		@line_index : Int;
		@keywords : Hash<String, IntHolder>;

		New(text : String) {
			@buffer := text->ToCharArray();
			@buffer_index := 0;

			@tokens := Vector->New()<ScannerToken>;
			@keywords := Hash->New()<String, IntHolder>;
			@keywords->Insert("return", IntHolder->New(Type->RETURN_ID));
			@keywords->Insert("class", IntHolder->New(Type->CLASS_ID));
			@keywords->Insert("use", IntHolder->New(Type->USE_ID));
			@keywords->Insert("enum", IntHolder->New(Type->ENUM_ID));
			@keywords->Insert("bundle", IntHolder->New(Type->BUNDLE_ID));
			@keywords->Insert("consts", IntHolder->New(Type->CONSTS_ID));
			@keywords->Insert("function", IntHolder->New(Type->FUNCTION_ID));
			@keywords->Insert("method", IntHolder->New(Type->METHOD_ID));
			@keywords->Insert("public", IntHolder->New(Type->PUBLIC_ID));
			@keywords->Insert("private", IntHolder->New(Type->PRIVATE_ID));
			@keywords->Insert("native", IntHolder->New(Type->NATIVE_ID));
			@keywords->Insert("static", IntHolder->New(Type->STATIC_ID));
			@keywords->Insert("Nil", IntHolder->New(Type->NIL_ID));
			@keywords->Insert("String", IntHolder->New(Type->STRING_ID));
			@keywords->Insert("Int", IntHolder->New(Type->INT_ID));
			@keywords->Insert("Float", IntHolder->New(Type->FLOAT_ID));
			@keywords->Insert("Char", IntHolder->New(Type->CHAR_ID));
			@keywords->Insert("Byte", IntHolder->New(Type->BYTE_ID));
			@keywords->Insert("each", IntHolder->New(Type->EACH_ID));
			@keywords->Insert("for", IntHolder->New(Type->FOR_ID));
			@keywords->Insert("while", IntHolder->New(Type->WHILE_ID));
			@keywords->Insert("if", IntHolder->New(Type->IF_ID));
			@keywords->Insert("else", IntHolder->New(Type->ELSE_ID));
			@keywords->Insert("As", IntHolder->New(Type->AS_ID));
		}

		method : NextChar() ~ Nil {
			if(@buffer_index + 1 < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;
				@next_char := @buffer[@buffer_index];
			}
			else if(@buffer_index < @buffer->Size()) {
				@cur_char := @buffer[@buffer_index++];
				@line_index += 1;				
				@next_char := '\0';
			}
			else {
				@cur_char := @next_char := '\0';
			};
		}

		method : Whitespace() ~ Nil {
			while(@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n') {
				if(@cur_char = '\n') {
					@line_num += 1;
					@line_index := 0;
				};

				NextChar();
			};
		}

		method : Comment() ~ Nil {
			if(@cur_char = '#') {
				NextChar();

				if(@cur_char = '~') {
					NextChar();
					while(<>(@cur_char = '~' & @next_char = '#') & @cur_char <> '\0') {
						if(@cur_char = '\n') {
							@line_num += 1;
						};
						NextChar();
					};
					NextChar();
					NextChar();
				}
				else {
					while(@cur_char <> '\n' & @cur_char <> '\0') {
						NextChar();
					};
					@line_num += 1;
					NextChar();
				};

				Whitespace();
			};
		}

		method : ParseIdentifier() ~ Nil {
			start := @buffer_index;
			start_index := @line_index - 1;

			while(@cur_char->IsChar() | @cur_char->IsDigit() | @cur_char = '.' | @cur_char = '_' | @cur_char = '@') {
				NextChar();
			};
			ident := String->New(@buffer, start - 1, @buffer_index - start);

			found := @keywords->Find(ident);
			if(found <> Nil) {
				type := found->Get()->As(ScannerToken->Type);
				@tokens->AddBack(ScannerToken->New(type, ident, @line_num, start_index));
			}
			else {
				@tokens->AddBack(ScannerToken->New(ScannerToken->Type->IDENT, ident, @line_num, start_index));
			};
		}

		method : ParseNumber() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			is_float := false;
			while(@cur_char->IsDigit() | @cur_char = '.' | @cur_char = 'u' | @cur_char = 'x') {
				if(@cur_char = '.') {
					is_float := true;
				};

				NextChar();
			};

			ident := String->New(@buffer, start - 1, @buffer_index - start);
			if(is_float) {
				@tokens->AddBack(ScannerToken->New(ident->ToFloat(), @line_num, start_index));
			}
			else {
				@tokens->AddBack(ScannerToken->New(ident->ToInt(), @line_num, start_index));
			};
		}

		method : ParseString() ~ Nil {
			start := @buffer_index;
			start_index := @line_index;

			prev_char := '\0';
			do {
				prev_char := @cur_char;
				NextChar();
			}
			while(<>(@cur_char = '"' & prev_char <> '\\') & @cur_char <> '\0');

			ident := String->New(@buffer, start, @buffer_index - start - 1);
			NextChar();

			@tokens->AddBack(ScannerToken->New(ScannerToken->Type->STRING_LIT, ident, @line_num, start_index));
		}

		method : ParseChar() ~ Nil {
			NextChar();

			if(@cur_char = '\\') {
				select(@next_char) {
					label 'r' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(ScannerToken->New('\r', @line_num, start_index));
					}

					label 'n' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(ScannerToken->New('\n', @line_num, start_index));
					}

					label 't' {
						NextChar();
						start_index := @line_index - 1;
						@tokens->AddBack(ScannerToken->New('\t', @line_num, start_index));
					}
				};
			}
			else {
				start_index := @line_index - 1;
				@tokens->AddBack(ScannerToken->New(@cur_char, @line_num, start_index));
			};

			NextChar();
			if(@cur_char = '\'') {
				NextChar();
				
			}
			else {
				start_index := @line_index - 1;
				@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OTHER, @cur_char, @line_num, start_index));
				NextChar();
			};
		}

		method : public : Scan() ~ Vector<ScannerToken> {
			NextChar();

			while(@cur_char <> '\0') {
				Whitespace();
				Comment();

				if(@cur_char->IsChar() | @cur_char = '@' | @cur_char = '_') {
					ParseIdentifier();
				}
				else if(@cur_char->IsDigit()) {
					ParseNumber();
				}
				else if(@cur_char = '"') {
					ParseString();
				}
				else if(@cur_char = '\'') {
					ParseChar();
				}
				else {
					select(@cur_char) {
						label '<' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->LES_EQL, @line_num, start_index));
								NextChar();
							}
							else if(@next_char = '>') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->NEQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->LES, @line_num, start_index));
								NextChar();
							};
						}

						label '>' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->GTR_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->GTR, @line_num, start_index));
								NextChar();
							};
						}

						label ';' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->SEMI_COLON, @line_num, start_index));
							NextChar();
						}

						label ',' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->COMMA, @line_num, start_index));
							NextChar();
						}

						label '{' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OCPN, @line_num, start_index));
							NextChar();
						}

						label '}' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->CCPN, @line_num, start_index));
							NextChar();
						}

						label '(' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OPN, @line_num, start_index));
							NextChar();
						}

						label ')' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->CPN, @line_num, start_index));
							NextChar();
						}

						label '=' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->EQL, @line_num, start_index));
							NextChar();
						}

						label ':' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ASSIGN, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->COLON, @line_num, start_index));
								NextChar();
							};
						}

						label '~' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->TILDE, @line_num, start_index));
							NextChar();
						}

						label '&' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->AND, @line_num, start_index));
							NextChar();
						}

						label '|' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OR, @line_num, start_index));
							NextChar();
						}

						label '[' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OBR, @line_num, start_index));
							NextChar();
						}

						label ']' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->CBR, @line_num, start_index));
							NextChar();
						}

						label '+' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ADD_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ADD, @line_num, start_index));
								NextChar();
							};
						}
						
						label '*' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->MUL_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->MUL, @line_num, start_index));
								NextChar();
							};
						}

						label '/' {
							if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->DIV_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->DIV, @line_num, start_index));
								NextChar();
							};
						}

						label '%' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->MOD, @line_num, start_index));
							NextChar();
						}

						label '-' {
							if(@next_char = '>') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ASSESSOR, @line_num, start_index));
								NextChar();
							}
							else if(@next_char = '=') {
								NextChar();
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->SUB_EQL, @line_num, start_index));
								NextChar();
							}
							else {
								start_index := @line_index - 1;
								@tokens->AddBack(ScannerToken->New(ScannerToken->Type->SUB, @line_num, start_index));
								NextChar();
							};
						}
						
						label'←' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ASSIGN, @line_num, start_index));
							NextChar();
						}

						label '→' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->ASSESSOR, @line_num, start_index));
							NextChar();
						}

						label '\0' {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->EOS, @line_num, start_index));
							NextChar();
						}

						other {
							start_index := @line_index - 1;
							@tokens->AddBack(ScannerToken->New(ScannerToken->Type->OTHER, @cur_char, @line_num, start_index));
							NextChar();
						}
					};
				};
			};

			@tokens->AddBack(ScannerToken->New(ScannerToken->Type->EOS, @line_num, 0));
			return @tokens;
		}
	}

	#
	# ScannerToken
	#
	class : private : ScannerToken {
		@type : ScannerToken->Type;
		@line_num : Int;
		@line_index : Int;
		@str_value : String;
		@int_value : Int;
		@float_value : Float;
		@char_value : Char;

		enum Type {
			OTHER,
			EOS,
			IDENT,
			STRING_LIT,
			INT_LIT,
			FLOAT_LIT,
			CHAR_LIT,
			EQL,
			NEQL,
			LES,
			GTR,
			LES_EQL,
			GTR_EQL,
			SEMI_COLON,
			ADD,
			SUB,
			MUL,
			DIV,
			MOD,
			ADD_EQL,
			SUB_EQL,
			MUL_EQL,
			DIV_EQL,
			COLON,
			COMMA,
			TILDE,
			AND,
			OR,
			OPN,
			CPN,
			OCPN,
			CCPN,
			OBR,
			CBR,
			ASSESSOR,
			ASSIGN,
			RETURN_ID,
			CLASS_ID,
			USE_ID,
			ENUM_ID,
			CONSTS_ID,
			FUNCTION_ID,
			METHOD_ID,
			PUBLIC_ID,
			PRIVATE_ID,
			BUNDLE_ID,
			NATIVE_ID,
			STATIC_ID,
			NIL_ID,
			STRING_ID,
			INT_ID,
			FLOAT_ID,
			CHAR_ID,
			BYTE_ID,
			EACH_ID,
			FOR_ID,
			WHILE_ID,
			IF_ID,
			ELSE_ID,
			AS_ID
		}

		New(type : ScannerToken->Type, line_num : Int, line_index : Int) {
			@type := type;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : ScannerToken->Type, str_value : String, line_num : Int, line_index : Int) {
			@type := type;
			@str_value := str_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(int_value : Int, line_num : Int, line_index : Int) {
			@type := ScannerToken->Type->INT_LIT;
			@int_value := int_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(float_value : Float, line_num : Int, line_index : Int) {
			@type := ScannerToken->Type->FLOAT_LIT;
			@float_value := float_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(char_value : Char, line_num : Int, line_index : Int) {
			@type := ScannerToken->Type->CHAR_LIT;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		New(type : ScannerToken->Type, char_value : Char, line_num : Int, line_index : Int) {
			@type := type;
			@char_value := char_value;
			@line_num := line_num;
			@line_index := line_index;
		}

		method : public : GetType() ~ ScannerToken->Type {
			return @type;
		}

		method : public : GetLine() ~ Int {
			return @line_num;
		}

		method : public : GetPos() ~ Int {
			return @line_index;
		}

		method : public : GetStringValue() ~ String {
			return @str_value;
		}

		method : public : GetIntValue() ~ Int {
			return @int_value;
		}

		method : public : GetFloatValue() ~ Float {
			return @float_value;
		}

		method : public : GetCharValue() ~ Char {
			return @char_value;
		}

		method : public : ToString() ~ String {
			buffer := "type=";

			select(@type) {
				label ScannerToken->Type->IDENT {
					buffer += "IDENT, value='{$@str_value}'";
				}

				label ScannerToken->Type->STRING_LIT {
					buffer += "STRING_LIT, value='{$@str_value}'";
				}

				label ScannerToken->Type->INT_LIT {
					buffer += "INT_LIT, value={$@int_value}";
				}
				
				label ScannerToken->Type->FLOAT_LIT {
					buffer += "FLOAT_LIT, value={$@float_value}";
				}
				
				label ScannerToken->Type->CHAR_LIT {
					buffer += "CHAR_LIT, value='{$@char_value}'";
				}

				label ScannerToken->Type->ASSESSOR {
					buffer += "ASSESSOR";
				}

				label ScannerToken->Type->SEMI_COLON {
					buffer += "SEMI_COLON";
				}

				label ScannerToken->Type->LES {
					buffer += "LES";
				}

				label ScannerToken->Type->LES_EQL {
					buffer += "LES_EQL";
				}

				label ScannerToken->Type->GTR_EQL {
					buffer += "GTR_EQL";
				}

				label ScannerToken->Type->GTR {
					buffer += "GTR";
				}

				label ScannerToken->Type->ENUM_ID {
					buffer += "ENUM_ID";
				}

				label ScannerToken->Type->CONSTS_ID {
					buffer += "CONSTS_ID";
				}

				label ScannerToken->Type->ADD_EQL {
					buffer += "ADD_EQL";
				}

				label ScannerToken->Type->SUB_EQL {
					buffer += "SUB_EQL";
				}

				label ScannerToken->Type->MUL_EQL {
					buffer += "MUL_EQL";
				}

				label ScannerToken->Type->DIV_EQL {
					buffer += "DIV_EQL";
				}

				label ScannerToken->Type->EQL {
					buffer += "EQL";
				}

				label ScannerToken->Type->NEQL {
					buffer += "NEQL";
				}

				label ScannerToken->Type->ADD {
					buffer += "ADD";
				}

				label ScannerToken->Type->SUB {
					buffer += "SUB";
				}

				label ScannerToken->Type->MUL {
					buffer += "MUL";
				}

				label ScannerToken->Type->DIV {
					buffer += "DIV";
				}

				label ScannerToken->Type->MOD {
					buffer += "MOD";
				}

				label ScannerToken->Type->ASSIGN {
					buffer += "ASSIGN";
				}

				label ScannerToken->Type->FUNCTION_ID {
					buffer += "FUNCTION_ID";
				}

				label ScannerToken->Type->METHOD_ID {
					buffer += "METHOD_ID";
				}

				label ScannerToken->Type->CLASS_ID {
					buffer += "CLASS_ID";
				}

				label ScannerToken->Type->RETURN_ID {
					buffer += "RETURN_ID";
				}

				label ScannerToken->Type->USE_ID {
					buffer += "USE_ID";
				}

				label ScannerToken->Type->PUBLIC_ID {
					buffer += "PUBLIC_ID";
				}

				label ScannerToken->Type->PRIVATE_ID {
					buffer += "PRIVATE_ID";
				}

				label ScannerToken->Type->BUNDLE_ID {
					buffer += "BUNDLE_ID";
				}

				label ScannerToken->Type->NATIVE_ID {
					buffer += "NATIVE_ID";
				}

				label ScannerToken->Type->STATIC_ID {
					buffer += "STATIC_ID";
				}

				label ScannerToken->Type->NIL_ID {
					buffer += "NIL_ID";
				}

				label ScannerToken->Type->STRING_ID {
					buffer += "STRING_ID";
				}

				label ScannerToken->Type->INT_ID {
					buffer += "INT_ID";
				}

				label ScannerToken->Type->FLOAT_ID {
					buffer += "FLOAT_ID";
				}

				label ScannerToken->Type->CHAR_ID {
					buffer += "CHAR_ID";
				}

				label ScannerToken->Type->BYTE_ID {
					buffer += "BYTE_ID";
				}

				label ScannerToken->Type->EACH_ID {
					buffer += "EACH_ID";
				}

				label ScannerToken->Type->FOR_ID {
					buffer += "FOR_ID";
				}

				label ScannerToken->Type->AS_ID {
					buffer += "AS_ID";
				}

				label ScannerToken->Type->WHILE_ID {
					buffer += "WHILE_ID";
				}

				label ScannerToken->Type->IF_ID {
					buffer += "IF_ID";
				}

				label ScannerToken->Type->ELSE_ID {
					buffer += "ELSE_ID";
				}

				label ScannerToken->Type->COLON {
					buffer += "COLON";
				}
				
				label ScannerToken->Type->COMMA {
					buffer += "COMMA";
				}
				
				label ScannerToken->Type->TILDE {
					buffer += "TILDE";
				}

				label ScannerToken->Type->AND {
					buffer += "AND";
				}

				label ScannerToken->Type->OR {
					buffer += "OR";
				}
				
				label ScannerToken->Type->OCPN {
					buffer += "OCPN";
				}
				
				label ScannerToken->Type->CCPN {
					buffer += "CCPN";
				}

				label ScannerToken->Type->OPN {
					buffer += "OPN";
				}
				
				label ScannerToken->Type->CPN {
					buffer += "CPN";
				}

				label ScannerToken->Type->OBR {
					buffer += "OBR";
				}

				label ScannerToken->Type->CBR {
					buffer += "CBR";
				}
				
				label ScannerToken->Type->OTHER {
					id := @char_value->As(Int);
					buffer += "OTHER: id={$id}, value='{$@char_value}'";
				}
			};
			buffer += ", line={$@line_num}, pos={$@line_index}";

			return buffer;
		}
	}

	#
	# Entity
	#
	class Entity {
		@name : String;
		@kind : Entity->Kind;
		@pos : ScannerToken;
		@parent : Entity;
		@children : Vector<Entity>;

		consts Kind {
			# REFS
			PACKAGE_REF:= 4,
			CLASS_REF := 5,
			METHOD_REF := 6,
			CONSTRUCTOR_REF := 9,
			ENUM_REF := 10,
			FUNCTION_REF := 12,
			VARIABLE_REF := 13,
			# SYMS
			CLASS_SYM := 105,
			FUNCTION_SYM := 112,
			METHOD_SYM := 106,
			CONSTRUCTOR_SYM := 109
		}

		New(name : String, kind : Entity->Kind, parent : Entity := Nil) {
			@name := name;
			@kind := kind;
			@parent := parent;
			@children := Vector->New()<Entity>;
		}

		method : public : AddChild(child : Entity) ~ Nil {
			@children->AddBack(child);
		}

		method : public : SetStart(start : ScannerToken) ~ Nil {
			@pos := start;
		}

		method : public : ToString() ~ String {
			return ToString(0);
		}

		method : public : ToString(depth : Int) ~ String {
			kind := @kind->As(Int);
			line := @pos->GetLine();
			start_pos := @pos->GetPos();
			end_pos := start_pos + @name->Size();

			buffer := "";
			each(i : depth) {
				buffer += '\t';
			};

			buffer += "[name={$@name}, kind={$kind}, line={$line}, start_pos={$start_pos}, end_pos={$end_pos}]";
			if(@children <> Nil) {
				each(i : @children) {
					child := @children->Get(i);
					buffer += '\n';
					buffer += child->ToString(depth + 1);
				};
			};

			return buffer;
		}

		method : public : GetReferences(find : String, uri : String) ~ JsonElement {
			array := JsonElement->New(JsonElement->JsonType->ARRAY);
			GetReferences(find, uri, array);
			return array;
		}

		method : public : GetReferences(find : String, uri : String, array : JsonElement) ~ Nil {
			if(@kind->As(Int) <= 100 & @name->Equals(find)) {
				builder := JsonBuilder->New();

				start_line := end_line := @pos->GetLine();
				start_index := @pos->GetPos();
				end_index := start_index + @name->Size();
				
				builder->PushObject();
				builder->Insert("uri", uri);

				builder->PushObject("range");
					obj := builder->PushObject("start");
					obj->Insert("line", start_line);
					obj->Insert("character", start_index);
					builder->Pop();

					obj := builder->PushObject("end");
					obj->Insert("line", end_line);
					obj->Insert("character", end_index);
					builder->Pop();
				builder->Pop();

				array->Add(builder->Pop());
			};

			if(@children <> Nil) {
				each(i : @children) {
					@children->Get(i)->GetReferences(find, uri, array);
				};
			};
		}

		method : public : GetSymbols() ~ JsonElement {
			array := JsonElement->New(JsonElement->JsonType->ARRAY);
			GetSymbols(array);
			return array;
		}

		method : public : GetSymbols(array : JsonElement) ~ Nil {
			builder := JsonBuilder->New();

			if(@kind->As(Int) > 100) {
				start_line := end_line := @pos->GetLine();
				start_index := @pos->GetPos();
				end_index := start_index + @name->Size();
				
				obj := builder->PushObject();
				obj->Insert("kind", @kind->As(Int) - 100);
				obj->Insert("name", @name);

					builder->PushObject("location");

						builder->PushObject("range");
							obj := builder->PushObject("start");
							obj->Insert("line", start_line);
							obj->Insert("character", start_index);
							builder->Pop();

							obj := builder->PushObject("end");
							obj->Insert("line", end_line);
							obj->Insert("character", end_index);
							builder->Pop();
						builder->Pop();

						builder->PushObject("selectionRange");
							obj := builder->PushObject("start");
							obj->Insert("line", start_line);
							obj->Insert("character", start_index);
							builder->Pop();

							obj := builder->PushObject("end");
							obj->Insert("line", end_line);
							obj->Insert("character", end_index);
							builder->Pop();
						builder->Pop();

				array->Add(builder->PopAll());
			};

			if(@children <> Nil) {
				each(i : @children) {
					@children->Get(i)->GetSymbols(array);
				};
			};
		}
	}
}