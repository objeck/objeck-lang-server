use System.IO.File;
use Collection.Generic;

class Scanner {
	@file : String;
	@tokens : Vector<Token>;
	@strings : Vector<String>;
	@line : String;
	@line_num : Int;
	@index : Int;

	New(file : String) {
		@file := file;
		@tokens := Vector->New()<Token>;
		@strings := Vector->New()<String>;;
	}
	
	method : public : GetTokens             () ~ Vector<Token> {
		return @tokens;
	}
	
	method : public : GetStrings() ~ Vector<String> {
		return @strings;
	}
	
	method : NextLine(reader : FileReader) ~ Nil {
		@line := reader->ReadLine();
		@line_num += 1;
		@index := 0;
	}
	
	method : Whitespace() ~ Nil {
		while(@index < @line->Size() & (@line->Get(@index) = ' ' | @line->Get(@index) = '\t')) {
			@index += 1;
		};
	}
	
	method : Comments(reader : FileReader) ~ Bool {
		if(@index + 1 < @line->Size()) {
			if(@line->Get(@index) = '#') {
				if(@line->Get(@index + 1) = '~') {
					@index += 2;
					
					comment_end := false;
					while(<>comment_end) {
						while(@index < @line->Size() & <>comment_end) {
							if(@index + 1 < @line->Size() & (@line->Get(@index) = '~' | @line->Get(@index + 1) = '#')) {
								comment_end := true;
								@index += 1;
							};
							@index += 1;
						};
						
						if(@index = @line->Size()) {
							NextLine(reader);
						};						
					};
					Whitespace();
					
					if(@index = @line->Size() & <>reader->IsEOF()) {
						NextLine(reader);
						Whitespace();
					};
					Comments(reader);
					
					return reader->IsEOF();
				}
				else {
					@line := reader->ReadLine();
					@line_num += 1;
					@index := 0;  
					while(@index < @line->Size() & (@line->Get(@index) = ' ' | @line->Get(@index) = '\t')) {
						@index += 1;
					};										
				};
			};			
		};
		
		return false;
	}
	
	method : public : native : Scan() ~ Bool {
		reserved := Map->New()<String, IntHolder>;
		reserved->Insert("use", IntHolder->New(Token->Type->USE_ID));
		reserved->Insert("while", IntHolder->New(Token->Type->WHILE_ID));
		reserved->Insert("do", IntHolder->New(Token->Type->DO_ID));
		reserved->Insert("for", IntHolder->New(Token->Type->FOR_ID));
		reserved->Insert("each", IntHolder->New(Token->Type->EACH_ID));
		reserved->Insert("select", IntHolder->New(Token->Type->SELECT_ID));
		reserved->Insert("label", IntHolder->New(Token->Type->IF_ID));
		reserved->Insert("if", IntHolder->New(Token->Type->IF_ID));
		reserved->Insert("else", IntHolder->New(Token->Type->ELSE_ID));
		reserved->Insert("class", IntHolder->New(Token->Type->CLASS_ID));
		reserved->Insert("function", IntHolder->New(Token->Type->FUNCTION_ID));
		reserved->Insert("Nil", IntHolder->New(Token->Type->NIL_ID));
		reserved->Insert("String", IntHolder->New(Token->Type->STRING_ID));
		
		reader := FileReader->New(@file);
		leaving {
			reader->Close();
		};
		
		string_count := 0;
		@line_num := 0;
		while(<>reader->IsEOF()) {
			# get line
			NextLine(reader);
			
			while(@index < @line->Size()) { 
				# skip whitespace
				Whitespace();
				
				# parse the @line
				if(@index < @line->Size() & <>Comments(reader)) {
					# variable
					if(@line->Get(@index)->IsChar() | @line->Get(@index) = '_') {
						string := "";
						while(@line->Get(@index)->IsChar() | @line->Get(@index)->IsDigit() | @line->Get(@index) = '_' | @line->Get(@index) = '.') {
							string->Append(@line->Get(@index));
							@index += 1;
						};
					
						token := reserved->Find(string)->As(IntHolder);
						if(token <> Nil) {
							type := token->Get()->As(Token->Type);
							@tokens->AddBack(Token->New(@line_num, type, string));
						}
						else {
							@tokens->AddBack(Token->New(@line_num, Token->Type->VAR, string));
						};
					}
					# number
					else if(@line->Get(@index)->IsDigit()) {
						number := "";
						while(@line->Get(@index)->IsDigit()) {
							number->Append(@line->Get(@index));
							@index += 1;
						};						
						@tokens->AddBack(Token->New(@line_num, Token->Type->NUM, "num", number->ToInt()));
					}
					# char
					else if(@line->Get(@index) = '\'') {
						@index += 1;
						if(@line->Get(@index) = '\\') {
							@index += 1;
							select(@line->Get(@index)) {
								label 'r': {
									@tokens->AddBack(Token->New(@line_num, Token->Type->CHAR, "char", '\r'));
									@index += 1;
								}
								
								label 'n': {
									@tokens->AddBack(Token->New(@line_num, Token->Type->CHAR, "char", '\n'));
									@index += 1;
								}
								
								label 't': {
									@tokens->AddBack(Token->New(@line_num, Token->Type->CHAR, "char", '\t'));
									@index += 1;
								}
								
								label '\\': {
									@tokens->AddBack(Token->New(@line_num, Token->Type->CHAR, "char", '\\'));
									@index += 1;
								}
							};
						}
						else {
							@tokens->AddBack(Token->New(@line_num, Token->Type->CHAR, "char", @line->Get(@index)));
							@index += 1;
						};
						
						if(@line->Get(@index) <> '\'') {
							System.IO.Standard->Print("{$@line_num}: *** Invalid token: char='")->Print(@line->Get(@index))->PrintLine("' ***");
							System.Runtime->Exit(1);
						};
						@index += 1;
					}
					# string
					else if(@line->Get(@index) = '"') {
						@index += 1;
						string := "";
						while(@line->Get(@index) <> '"' & @line->Get(@index) <> '\0') {
							string->Append(@line->Get(@index));
							@index += 1;
						};
						@strings->AddBack(string);
						
						@tokens->AddBack(Token->New(@line_num, Token->Type->STR_REF, "string", string_count));						
						string_count += 1;
						@index += 1;
					}
					# other
					else {
						select(@line->Get(@index)) {
							label ',': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->COMMA, ","));
							}

							label '~': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->TILDE, "~"));
							}

							label ':': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '=') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->ASGN, ":="));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->COLON, ":"));
								};
							}
							
							label '(': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->OPREN, "("));
							}
						
							label ')': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->CPREN, ")"));
							}
				
							label '{': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->OCBRACE, "{"));
							}
				
							label '}': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->CCBRACE, "}"));
							}

							label '[': {
								
								@tokens->AddBack(Token->New(@line_num, Token->Type->OBRACE, "["));
							}
				
							label ']': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->CBRACE, "]"));
							}

							label '/': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->DIV, "/"));
							}
							
							label '%': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->MOD, "%"));
							}

							label '*': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->MUL, "*"));
							}

							label '+': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->ADD, "+"));
							}

							label 'â†’': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->ASSESSOR, "->"));
							}
							
							label '-': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '>') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->ASSESSOR, "->"));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->SUB, "-"));
								};
							}
						
							label ';': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->SEMI, ";"));
							}
							
							label '<': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '=') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->LESS_EQL, "<="));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->LESS, "<"));
								};
							}
							
							label '>': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '=') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->GTR_EQL, ">="));
									@index += 1;
								}
								else if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '>') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->NEQL, "<>"));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->GTR, ">"));
								};
							}
							
							label '=': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '=') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->EQL, ">"));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->EQL, "="));
								};
							}
							
							label '&': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '&') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->AND, "&"));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->OTHER, "OTHER"));
								};
							}
							
							label '|': {
								if(@index + 1 < @line->Size() & @line->Get(@index + 1) = '|') {
									@tokens->AddBack(Token->New(@line_num, Token->Type->OR, "|"));
									@index += 1;
								}
								else {
									@tokens->AddBack(Token->New(@line_num, Token->Type->OTHER, "OTHER"));
								};
							}
							
							label '!': {
								@tokens->AddBack(Token->New(@line_num, Token->Type->NOT, "!"));
							}
							
							other: {
								System.IO.Standard->Print("{$@line_num}: *** Invalid token: char='")->Print(@line->Get(@index))->PrintLine("' ***");
								System.Runtime->Exit(1);
							}
						};
						@index += 1;
					};  
				};
			};
		};
		@tokens->AddBack(Token->New(@line_num, Token->Type->EOS, "eos"));
		
		return true;
	}
}

class Token {
	@@line_num : Int;
	@type : Token->Type;
	@name : String;
	@value : Int;

	enum Type := -64 {
		USE_ID,
		WHILE_ID,
		DO_ID,
		FOR_ID,
		EACH_ID,
		SELECT_ID,
		NIL_ID,
		STRING_ID,
		CLASS_ID,
		FUNCTION_ID,
		ELSE_ID,
		IF_ID,
		ASGN,
		NUM,
		CHAR,
		STR_REF,
		VAR,
		OPREN,
		CPREN,
		OBRACE,
		CBRACE,
		OCBRACE,
		CCBRACE,
		ASSESSOR,
		AND,
		OR,
		DIV,
		MOD,
		MUL,
		ADD,
		SUB,
		COLON,
		SEMI,
		COMMA,
		TILDE,
		LESS,
		LESS_EQL,
		GTR,
		GTR_EQL,
		EQL,
		NEQL,
		NOT,
		EOS,
		OTHER
	}
	
	New(@line_num : Int, type : Token->Type, name : String) {
		@@line_num := @line_num;
		@type := type;
		@name := name;
	}
	
	New(@line_num : Int, type : Token->Type, name : String, value : Int) {
		@@line_num := @line_num;
		@type := type;
		@value := value;
		@name := name;
	}
	
	method : public : GetLine() ~ Int {
		return @@line_num;
	}
	
	method : public : GetType() ~ Token->Type {
		return @type;
	}
	
	method : public : GetName() ~ String {
		return @name;
	}
	
	method : public : GetValue() ~ Int {
		return @value;
	}

	method : public : ToString() ~ String {
		select(@type) {
			label Token->Type->STR_REF:
			label Token->Type->NUM: {
				return @value->ToString();
			}
			
			other: {
				return @name;
			}
		};

		return "<unknown>";
	}
}