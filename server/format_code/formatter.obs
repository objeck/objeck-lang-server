use System.IO.File;
use Collection.Generic;

class CodeFormatter {
	function : Format(source : String, options : Map<String, String>) ~ String {
		# get options
		stmt_space_check := options->Find("function-space");
		stmt_space := stmt_space_check <> Nil & stmt_space_check->Equals("true");

		ident_space_check := options->Find("ident-space");
		ident_space := 0;
		if(ident_space_check <> Nil & <>ident_space_check->IsEmpty()) {
			ident_space := ident_space_check->ToInt();
		};

		buffer := "\n---\n";

		scanner := Scanner->New(source);
		if(scanner->Scan()) {
			tab_space := 0;
			insert_tabs := false;

			no_space := false;
			in_label := false;
			in_for := false;

			token, next_token : Token;
			prev_token := Token->New(-1, Token->Type->OTHER, "other");

			tokens := scanner->GetTokens();
			each(i : tokens) {
				if(insert_tabs) {
					TabSpace(tab_space, ident_space, buffer);
					insert_tabs := false;
				};

				# set current, previous and next tokens
				if(token <> Nil) {
					prev_token := token;
				};

				if(next_token <> Nil) {
					token := next_token;
				}
				else {
					token := tokens->Get(i);
				};

				if(i + 1 < tokens->Size()) {
					next_token := tokens->Get(i + 1);
				}
				else {
					next_token := Token->New(-1, Token->Type->OTHER, "other");
				};
				
				select(token->GetType()) {
					label Token->Type->CLASS_ID {
						VerticalSpace(prev_token, tab_space, ident_space, buffer);
						buffer += "class";
					}

					label Token->Type->FUNCTION_ID {
						VerticalSpace(prev_token, tab_space, ident_space, buffer);
						buffer += "function";
					}

					label Token->Type->METHOD_ID {
						VerticalSpace(prev_token, tab_space, ident_space, buffer);
						buffer += "method";
					}

					label Token->Type->PUBLIC_ID {
						buffer += "public";
					}

					label Token->Type->PRIVATE_ID {
						buffer += "private";
					}

					label Token->Type->IF_ID {
						buffer += "if";
					}

					label Token->Type->ELSE_ID {
						buffer += '\n';
						TabSpace(tab_space, ident_space, buffer);
						buffer += "else";
					}					

					label Token->Type->WHILE_ID {
						buffer += "while";
					}

					label Token->Type->FOR_ID {
						buffer += "for";
						in_for := true;
					}

					label Token->Type->EACH_ID {
						buffer += "each";
					}

					label Token->Type->BREAK_ID {
						buffer += "break";
					}

					label Token->Type->RETURN_ID {
						buffer += "return";
					}

					label Token->Type->ALIAS_ID {
						buffer += "alias";
					}

					label Token->Type->LEAVING_ID {
						buffer += "leaving";
					}

					label Token->Type->USE_ID {
						buffer += "use";
					}

					label Token->Type->NATIVE_ID {
						buffer += "native";
					}

					label Token->Type->STATIC_ID {
						buffer += "static";
					}

					label Token->Type->SELECT_ID {
						buffer += "select";
					}

					label Token->Type->LABEL_ID {
						VerticalSpace(prev_token, tab_space, ident_space, buffer);
						buffer += "label";
						in_label := true;
					}

					label Token->Type->OTHER_ID {
						VerticalSpace(prev_token, tab_space, ident_space, buffer);
						buffer += "other";
						in_label := true;
					}

					label Token->Type->ASGN {
						buffer += ":=";
					}

					label Token->Type->ASSESSOR {
						buffer->Pop();
						buffer += "->";
					}

					label Token->Type->LINE_COMMENT {
						buffer += '#';
						buffer += token->GetValue();
					}

					label Token->Type->MULTI_COMMENT {
						buffer += "#~";
						buffer += token->GetValue();
						buffer += "~#";
					}

					label Token->Type->SEMI {
						buffer->Pop();
						buffer += ';';
						if(next_token->GetType() <> Token->Type->CCBRACE & next_token->GetType() <> Token->Type->VTAB & <>in_for) {
							buffer += '\n';
						};

						if(<>in_for) {
							insert_tabs := true;
						};
					}

					label Token->Type->LESS {
						buffer += '<';
					}

					label Token->Type->GTR {
						buffer += '>';
					}

					label Token->Type->COMMA {
						buffer->Pop();
						buffer += ',';
					}

					label Token->Type->NEQL {
						buffer += "<>";
					}

					label Token->Type->IDENT {
						if(prev_token->GetType() = Token->Type->ASSESSOR | 
								prev_token->GetType() = Token->Type->ADD_ADD | 
								prev_token->GetType() = Token->Type->SUB_SUB) {
							buffer->Pop();
						};
						value := token->GetValue();
						buffer += "{$value}";
					}

					label Token->Type->STRING_LIT {
						buffer += '"';
						buffer += token->GetValue();
						buffer += '"';
					}

					label Token->Type->CHAR_LIT {
						buffer += '\'';
						buffer += token->GetValue();
						buffer += '\'';
					}

					label Token->Type->NUM_LIT {
						buffer += token->GetValue();
					}

					label Token->Type->STRING_ID {
						buffer += "String";
					}

					label Token->Type->INT_ID {
						buffer += "Int";
					}

					label Token->Type->FLOAT_ID {
						buffer += "Float";
					}

					label Token->Type->CHAR_ID {
						buffer += "Char";
					}

					label Token->Type->BOOL_ID {
						buffer +=  "Bool";
					}

					label Token->Type->BYTE_ID {
						buffer +=  "Byte";
					}

					label Token->Type->NIL_ID {
						buffer +=  "Nil";
					}

					label Token->Type->COLON {
						if(in_label) {
							buffer->Pop();
						};
						buffer += ':';
					}

					label Token->Type->ADD {
						buffer += '+';
					}

					label Token->Type->SUB {
						buffer += '-';
					}

					label Token->Type->MUL {
						buffer += '*';
					}

					label Token->Type->DIV {
						buffer += '/';
					}

					label Token->Type->MOD {
						buffer += '%';
					}

					label Token->Type->FWD_SLASH {
						buffer += '\'';
					}

					label Token->Type->EQL {
						buffer += '=';
					}

					label Token->Type->LESS_EQL {
						buffer += "<=";
					}

					label Token->Type->GTR_EQL {
						buffer += ">=";
					}

					label Token->Type->ADD_ASN {
						buffer += "+=";
					}

					label Token->Type->SUB_ASN {
						buffer += "-=";
					}

					label Token->Type->ADD_ADD {
						buffer += "++";
					}

					label Token->Type->SUB_SUB {
						buffer += "--";
					}

					label Token->Type->MUL_ASN {
						buffer += "*=";
					}

					label Token->Type->DIV_ASN {
						buffer += "/=";
					}

					label Token->Type->TILDE {
						buffer += '~';
					}

					label Token->Type->OBRACE {
						if(prev_token->GetType() = Token->Type->IDENT) {
							buffer->Pop();
						};
						buffer += '[';
						no_space := true;
					}

					label Token->Type->CBRACE {
						if(prev_token->GetType() <> Token->Type->OBRACE) {
							buffer->Pop();
						};
						buffer += ']';
					}

					label Token->Type->OPREN {
						if(<>stmt_space) {
							select(prev_token->GetType()) {
								label Token->Type->IDENT
								label Token->Type->IF_ID
								label Token->Type->FOR_ID
								label Token->Type->EACH_ID
								label Token->Type->SELECT_ID
								label Token->Type->WHILE_ID {
									buffer->Pop();
								}
							};
						};

						buffer += '(';
						no_space := true;
					}

					label Token->Type->CPREN {
						if(prev_token->GetType() <> Token->Type->OPREN) {
							buffer->Pop();
						};

						if(in_for) {
							in_for := false;
						};

						buffer += ')';
					}

					label Token->Type->OCBRACE {
						buffer += "{\n";
						tab_space += 1;
						insert_tabs := true;

						if(in_label) {
							in_label := false;
						};
					}

					label Token->Type->CCBRACE {
						buffer += '\n';
						tab_space -= 1;
						TabSpace(tab_space, ident_space, buffer);
						buffer += '}';
					}

					label Token->Type->VTAB {
						if(next_token->GetType() <> Token->Type->CCBRACE) {
							buffer += '\n';
							TabSpace(tab_space, ident_space, buffer);
							no_space := true;
						};
					}

					other {
					}
				};

				if(<>no_space) {
					buffer += " ";
				}
				else {
					no_space := false;
				};
			};
		};

		return buffer;
	}

	function : VerticalSpace(prev_token : Token, tab_space : Int, ident_space : Int, buffer : String) ~ Nil {
		if(prev_token->GetType() = Token->Type->VTAB) {
			buffer += '\n';
			TabSpace(tab_space, ident_space, buffer);
		}
		else if(prev_token->GetType() = Token->Type->CCBRACE) {
			buffer += "\n\n";
			TabSpace(tab_space, ident_space, buffer);
		};
	}

	function : TabSpace(tab_space : Int, ident_space : Int, buffer : String) ~ Nil {
		if(ident_space > 0) {
			each(i : tab_space) {
				each(j : ident_space) {
					buffer += ' ';
				};
			};
		}
		else {
			each(i : tab_space) {
				buffer += '\t';
			};
		};
	}
}