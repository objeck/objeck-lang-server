use System.IO.File;
use Collection.Generic;

class CodeFormatter {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {			
			input := FileReader->ReadFile(args[0]);
			if(input <> Nil) {
				scanner := Scanner->New(input);
				if(scanner->Scan()) {
					buffer := "";

					tab_space := 0;
					insert_tabs := false;

					no_space := false;
					chomp_space := false;

					token : Token;
					prev_token := Token->New(-1, Token->Type->OTHER, "other");

					tokens := scanner->GetTokens();
					each(i : tokens) {
						if(insert_tabs) {
							TabSpace(tab_space, buffer);
							insert_tabs := false;
						};

						if(token <> Nil) {
							prev_token := token;
						};
						token := tokens->Get(i);
						
						select(token->GetType()) {
							label Token->Type->CLASS_ID {
								buffer += "class";
							}

							label Token->Type->FUNCTION_ID {
								buffer += "function";
							}

							label Token->Type->IF_ID {
								buffer += "if";
							}

							label Token->Type->ASGN {
								buffer += ":=";
							}

							label Token->Type->ASSESSOR {
				buffer->Pop();
								buffer += "->";
							}

							label Token->Type->SEMI {
				buffer->Pop();
								buffer += ";\n";
								insert_tabs := true;
							}

							label Token->Type->LESS {
								buffer += '<';
							}

							label Token->Type->GTR {
								buffer += '>';
							}

							label Token->Type->NEQL {
								buffer += "<>";
							}

							label Token->Type->IDENT {
			if(prev_token->GetType() = Token->Type->ASSESSOR) {
				buffer->Pop();
			};
								value := token->GetValue();
								buffer += "{$value}";
							}

							label Token->Type->COLON {
								buffer += ':';
							}

							label Token->Type->ADD {
								buffer += '+';
							}

							label Token->Type->TILDE {
								buffer += '~';
							}

							label Token->Type->INT_NUM {
								buffer += token->GetInt();
							}

							label Token->Type->FLOAT_NUM {
								buffer += token->GetFloat();
							}

							label Token->Type->OBRACE {
			if(prev_token->GetType() = Token->Type->IDENT) {
				buffer->Pop();
			};
								buffer += '[';
			no_space := true;
							}

							label Token->Type->CBRACE {
			if(prev_token->GetType() <> Token->Type->OBRACE) {
				buffer->Pop();
			};
								buffer += ']';
							}

							label Token->Type->OPREN {
			if(prev_token->GetType() = Token->Type->IDENT) {
				buffer->Pop();
			};

								buffer += '(';
			no_space := true;
							}

							label Token->Type->CPREN {
			if(prev_token->GetType() <> Token->Type->OPREN) {
				buffer->Pop();
			};
								buffer += ')';
							}

							label Token->Type->OCBRACE {
								buffer += "{\n";
								tab_space += 1;
								insert_tabs := true;
							}

							label Token->Type->CCBRACE {
								buffer += '\n';
								tab_space -= 1;
								TabSpace(tab_space, buffer);
								buffer += '}';
							}

							other {

							}
						};

						if(<>no_space) {
							buffer += " ";
						}
						else {
							no_space := false;
						};
					};

					# show buffer
					buffer->PrintLine();
				};
			};
		};
	}

	function : TabSpace(space : Int, buffer : String) ~ Nil {
		each(i : space) {
			buffer += '\t';
		};
	}
}